#! /bin/bash

## License:
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public
#   License as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later
#   version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public
#   License along with this program.  If not, see
#   <https://www.gnu.org/licenses/>.
#
## You can redistribute it as you wish : GPL v3
## author : wildtruc@noneltd.net

## You can place the script everywhere, but /usr/local/bin is still the best
## You can rename the script as you wish
## usage : winestart CONFIGFILE 

## define per game conf files dir
scpt_dir=$HOME/.winestarter
w_tricks=$(find /usr/{bin,local/bin} -name winetricks)
zen_bin=$(find /usr/{bin,local/bin} -name zenity)
convert_bin=$(find /usr/{bin,local/bin} -name convert)
wres_bin=$(find /usr/{bin,local/bin} -name wrestool)
icot_bin=$(find /usr/{bin,local/bin} -name icotool)
strings_bin=$(find /usr/{bin,local/bin} -name strings)
rpm_bin=$(find /usr/{bin,local/bin} -name rpm2cpio)
cab_bin=$(find /usr/{bin,local/bin} -name cabextract)
#yad_bin=$(find /usr/{bin,local/bin} -name yad)

wine_bin='wine'
wineboot_bin='wineboot'
wineserver_bin='wineserver'
conf=$1

## create the user script conf directory if it doesn't exist
[[ -d $scpt_dir ]]|| mkdir -p $scpt_dir
## Is per game specific wine conf file exist ?
[[ -s $scpt_dir/configs/$conf ]]|| exit 0
config_file=$scpt_dir/configs/$conf
 . $scpt_dir/configs/$conf
 . $scpt_dir/color.conf

[[ $auto_set ]]|| auto_set=0
[[ $set_desktop_env ]]|| set_desktop_env=0
[[ $use_optimus ]]|| use_optimus=0
[[ $use_winepath ]]|| use_winepath=0
[[ $w_install_tricks ]]|| w_install_tricks=0
[[ $w_install_exe ]]|| w_install_exe=0
[[ $w_config ]]|| w_config=0
##define user home desktop directory
if [ -e $HOME/.config/user-dirs.dirs ]; then
	. $HOME/.config/user-dirs.dirs
fi
## yad fonts colors
vb='<span color="'$main'" weight="bold" font="'$font0' '$size0'">'
vn='<span color="'$main'" weight="normal" font="'$font0' '$size0'">'
rb='<span color="'$warn'" weight="bold" font="'$font0' '$size0'">'
gb='<span color="'$freeze'" weight="bold" font="'$font0' '$size0'">'
bf='<span color="'$main'" weight="bold" font="'$font1' '$size1'">'
brf='<span color="'$warn'" weight="bold" font="'$font1' '$size1'">'
nf='<span weight="bold" font="'$font0' '$size0'">'
end='</span>'

## yad warning messages
png_stock=$HOME/.winestarter/png/defaults
filesave=$png_stock/'wine-install48.png'
warning=$png_stock/'wine-warn48.png'
inform=$png_stock/'wine-info48.png'
kill_img=$png_stock/'bottle_manager48.png'
#kill_img=$png_stock/'control_panel16.png'
# text=""; dialog_list="$text;gtk-close;$inform"; yad_warnings
#yad_warning(){
##	d_txt=$(printf "$dialog_list"|cut -d';' -f1)
#	d_btt=$(printf "$dialog_list"|cut -d';' -f1)
#	d_img=$(printf "$dialog_list"|cut -d';' -f2)
#	w_width=500
#	if [ $yad_bin ]; then
#		$yad_bin --width=$w_width --height=$(($w_width/3)) --title "" --borders 15 --button="$d_btt":1 \
#		--image=$d_img --text="$text" --timeout=3
##	$yad_bin --width=400 --height=100 --title "" --button="$d_btt":1 \
##	--image=$d_img --timeout=3 --form --field="$text":LBL ''
#	else
#		[ $zen_bin ]&& zen_warning
#	fi
##	zenity --height=150 --title='' --warning --window-icon=$d_img --text="$text" --timeout=3
#}
zen_warning(){
	## model line: "gtk-close;'info/warn image';'height divider';'window time-out'"
	d_btt=$(printf "$dialog_list"|cut -d';' -f1)
	d_img=$(printf "$dialog_list"|cut -d';' -f2)
	div=$(printf "$dialog_list"|cut -d';' -f3)
	time=$(printf "$dialog_list"|cut -d';' -f4)
	w_width=400 ; w_height=$(($w_width/$div))
	$zen_bin --width=$w_width --height=$w_height --title='' --warning --window-icon="$d_img" \
	 --timeout=$time --text="$text"
}
zen_question(){
	d_btt=$(printf "$dialog_list"|cut -d';' -f1)
	d_img=$(printf "$dialog_list"|cut -d';' -f2)
	bt_do=$(printf "$dialog_list"|cut -d';' -f3)
	bt_undo=$(printf "$dialog_list"|cut -d';' -f4)
	w_width=500
	$zen_bin --width=$w_width --title='' --question --window-icon=$d_img --ok-label="$bt_do" \
	--cancel-label="$bt_undo" --text="$text"
}
fn_wipe_cache(){
## Control system cache memory. If too high, display an admin window and ask to clear it with warnings.
## use /proc/meminfo MemTotal / Buffers / Cached+Slab (critical avaluate on 60% Buffers+Cached+Slab)
## define critical left free memory
critical='40'
## use 'free' systeù tool to define memory class
m_total=$(free -wm | sed -n "/Mem/p"| awk '{print $2}')
m_used=$(free -wm | sed -n "/Mem/p"| awk '{print $3}')
m_cache=$(free -wm | sed -n "/Mem/p"| awk '{print $7}')
## translate in percentage
_m_used=$(($((100*$m_used))/$m_total))
_m_cache=$(($((100*$m_cache))/$m_total))
_m_free=$(($((100*$(($m_total-$(($m_used+$m_cache))))))/$m_total))
## if total free memory is lower than defined critical then start wipe process
if [ $_m_free -le $critical ]; then
## unless cache memory is higher than real memory used, do not continue.
	if [ $_m_cache -gt $_m_used ]; then
		_cc_total=$(($m_used+$m_cache))
		_cc_used=$(($((100*$m_used))/$_cc_total))
		_cc_cache=$(($((100*$m_cache))/$_cc_total))
		if [ $_cc_used -le $critical ]; then
			echo -e "»»»» Memory cache used over $_cc_cache% (left:$_m_free%)"
			text="$vb\\Memory cache is using $_m_cache% of RAM. You can wipe it or leave it as it is. Some apps are known to use a lot of cache memory, so be careful and know what you're doing.$end\\n\\n$brf\\WARNING$end$vb Do not use if your system is a production server, it may wipe all servers cached data.$end"
			dialog_list="gtk-close;$warning;Wipe;Cancel"; zen_question
			if [ $? = 0 ]; then
				if [[ $EUID -ne 0 ]]; then
#					pkexec /usr/local/sbin/winestarter_cache
					pkexec sh -c "echo -e \"»»»» Cleaning memory cache.\"; sync; echo 3 > /proc/sys/vm/drop_caches"
				fi
			fi
		fi
	fi
else
	echo -e "»»»» Memory cache used under critical (left:$_m_free%). Clear"
fi
}
## optimus special sets (1)
fn_optimus(){
	export vblank_mode=$opti_VBLK
	export PRIMUS_SYNC=$opti_SYNC
	if [[ $opti_starter != primusrun ]]; then opti_opt='-b '; fi
	opti_run="$opti_starter $opti_opt$opti_accel"
}
## use_winepath sub.
fn_download_ui(){
	if [ $dl_installer = 1 ]; then
		dl_cmd(){ wget -O $dl_dir/$pack_name $pkgs 2>&1; }
	else
		dl_cmd(){ wget $pkgs $dl_dir/ 2>&1; }
	fi
	## This perl regex Analyse and parse wget stdout field, then display it in a yad window
	track(){ perl -p -e "$| = 1; s/^.* +([0-9]+%) +([0-9,.]+[GMKB]) +([0-9hms,.]+).*$/\1\n# $pck_dsp [\1] time left: \3\t\2\/s/"; }
	pkg_ext=$(printf "$pkgs"| sed -n "s/^.*\.//p")
	site=$(printf "$pkgs"| sed -E -n "s/(^.*:\/\/)(\w+)\.(\w+)\.(\w+)\/.*$/\2.\3.\4/p")
	pack=$(printf "$pkgs"| sed -n "s/^.*\///p")
	pck_dsp=$(printf "$pack"| sed -En "s/.\w*[0-9].rpm//p")
	w_text="Downloading from $site server."
	## zenity progress bar
	dl_cmd | track | $zen_bin --width=550 --title "$w_text" \
	--window-icon=filesave --progress --auto-close --no-cancel
}
## wine binary config and use (2).
fn_use_winepath(){
	unset dl_list os_version
	## create tmp dir for package download
	dl_dir=$(mktemp --tmpdir -d wine_dl.XXXXXXXX)	
	pkg_ver=$(printf $wine_ver| cut -d'-' -f1)
	pkg_rel=$(printf $wine_ver| cut -d'-' -f2)
	download_list(){
		if [ $wine_pack -gt 0 ]; then
			wget -O $file_temp $dl_address/
			os_version=$(tac $file_temp | egrep -o "indexcolname.*href=\"[0-9]{2}\/\""| \
			sed -En "s/^.*([0-9]{2}).*$/\1/p")
			for os_v in ${os_version[@]}; do
				wget --read-timeout=10 -O $file_temp.[$os_v] $dl_address/$os_v/$http_elf/
				dl_bin_list[$os_v]=$(tac $file_temp.[$os_v]| egrep "wine-$hq_stage$b_elf-[0-9]+"|\
				sed -En "s/^.*$b_elf-([0-9]\.[0-9]{1,2}(\.[0-9]{1,2})?)-([0-9](.rc[0-9])?).$http_elf.*$/\1-\3-$hq_stage,$os_v/p")
				if [ $os_v_p ]; then
					if [ $os_v -ne $os_v_p ]; then
						new_output=$(echo "${dl_bin_list[$os_v]}"| cut -d',' -f1)
						prev_output=$(echo "${dl_bin_list[$os_v_p]}"| cut -d',' -f1)
						_diff=$(echo "$new_output"| grep -vc "$prev_output")
						if [ $_diff -gt 0 ]; then
							_added=$(echo "${dl_bin_list[$os_v]}"| grep -v "$prev_output")
							dl_bin_list[$os_v]=$(echo -e "${dl_bin_list[$os_v_p]}\n$_added")
							dl_final_list=${dl_bin_list[$os_v]}
						fi
						os_v_p=$os_v
					fi
				else
					os_v_p=$os_v
				fi
			done
		else
			wget -O $file_temp $dl_address
			## limit PoL Wine version list from 1.4 to 1.8.6
			dl_bin_list=( "$(tac "$file_temp"| cut -d';' -f2| sed -n '/1\.8\.6.*$/,/^1\.4$/p')" )
		fi
		echo "$dl_final_list"| grep "$wine_ver"| cut -d',' -f2 > $file_temp.[stamp]
	}
	## set Wine binary environment arch.
	if [ $wine_elf = 1 ]; then ftp_elf='amd64'; b_elf='64'; else ftp_elf='x86'; b_elf=''; fi
	## if system context (distro) is mainly 64bits, prefer to install Wine 64bits packainstead of 32.
	sys_arch=$(uname -m)
	if [[ $sys_arch =~ ^.*64 ]]; then
		ftp_elf='amd64'; b_elf='64'
	fi
	## control if wine bin dir exist. If not create it from default
	if ! [[ -n $wine_path/$ftp_elf/ ]]; then mkdir -p $HOME/.winebin/$ftp_elf; fi
	if [[ -d $wine_path/$ftp_elf/$wine_ver ]]; then
		_use_winepath_env=1
	else
		w_title="Winestarter"
		## create the download list to fill in the yad loop.
		if [ $wine_pack -gt 0 ]; then
			if [ $wine_elf = 1 ]; then http_elf='x86_64'; else http_elf='i686'; fi
			## Check again system arch.
			if [[ $sys_arch =~ ^.*64 ]]; then
				http_elf='x86_64'
			fi
			## identify Wine version type
			if [[ $wine_ver =~ ^.*staging.*$ ]]; then
				hq_stage='staging'; hq_short='staging'
			elif [[ $wine_ver =~ ^.*stable.*$ ]]; then
				hq_stage='stable'; hq_short='stable'
			else
				hq_stage='development'; hq_short='devel'
			fi
			file_temp=$(mktemp --tmpdir ftp.XXXX)
			## identify Wine repo type.
			if [ $wine_pack = 2 ]; then dir_ver='wine-builds.old'; else dir_ver='wine-builds'; fi
			## tag to identify already download lists.
			case $hq_stage in
				'staging')
					if [ "$dir_ver" = 'wine-builds.old' ]]; then hq_ver='hq_stg1'; hq_ver='hq_stg0'; fi
				;;
				'stable') hq_ver='hq_stb0' ;;
				'development') hq_ver='hq_dev0' ;;
			esac
			
			dl_address="https://dl.winehq.org/$dir_ver/fedora"
			dl_text="$vb\\Building WineHQ packages repository list.$end"		
			download_list | $zen_bin --width=550 --title "$w_title" --text="$dl_text" \
			--window-icon=filesave --progress --pulsate --auto-close --no-cancel
			dist_dl_ver=$(cat $file_temp.[stamp])
			dl_address_0="$dl_address/$dist_dl_ver/$http_elf"
			dl_address_1="$dl_address/$dist_dl_ver/i686"
			dl_list=(
				"$dl_address_0/wine-$hq_stage$b_elf-$pkg_ver-$pkg_rel.$http_elf.rpm"
				"$dl_address_1/wine-$hq_stage-common-$pkg_ver-$pkg_rel.i686.rpm"
			)
			unpack_list=(
				"wine-$hq_stage$b_elf-$pkg_ver-$pkg_rel.$http_elf.rpm"
				"wine-$hq_stage-common-$pkg_ver-$pkg_rel.i686.rpm"
			)
		else
			dl_address_0="http://wine.playonlinux.com/binaries/linux-$ftp_elf"
			dl_pkg=PlayOnLinux-wine-$wine_ver-linux-$ftp_elf.pol
			dl_list=( "$dl_address_0/$dl_pkg" )
			unpack_list=( $dl_pkg )
			if [ $b_elf -ne 64 ]; then h_elf='32'; fi
			hq_ver='pol'$h_elf
		fi
		kill $WAIT_UI
		cd $dl_dir
		for pkgs in ${dl_list[@]}; do
			dl_installer=0
			pack_name=$wine_ver
			fn_download_ui
		done

		for dwld in ${unpack_list[@]}; do
			if [ $wine_pack = 0 ]; then 
				un_tar(){ tar -xf $dwld; }
			else
				un_tar(){ $rpm_bin $dwld | cpio -id; }
			fi
			if [ $(ls -1 $dl_dir| egrep -c "$pkg_ver") -gt 0 ]; then
				e_text="$vb\\Extracting $dwld to $wine_path.$end"
#			$yad_bin --width=550 --title "$w_title" --text-align=center --no-buttons \
#			--window-icon=filesave --progress --pulsate --auto-close --text="$e_text"  --progress-text="" &
#			WAIT_UI=$(ps -A | grep "yad" | awk '{print $1}'| sed -n '1p')
				$zen_bin --width=550 --title "$w_title" --window-icon=filesave \
				--progress --pulsate --auto-close --no-cancel --text="$e_text" &
				WAIT_UI=$(ps -A | grep "zenity" | awk '{print $1}'| sed -n '1p')
#			un_tar | $yad_bin --width=500 --title "$w_title" --text-align=center --no-buttons\
#			--window-icon=filesave --progress --pulsate --auto-close --text="$e_text" --progress-text=""
				un_tar
				kill $WAIT_UI
				_use_winepath_env=1
			else
				echo -e "»»»» Downloaded package missing. Using defautl Wine if any."
				if [ $zen_bin ]; then
					text="$bf\\Downloaded package missing$end$vb.\nUsing system default Wine instead if any.$end"
					dialog_list="gtk-close;$warning;4;4"; zen_warning
				fi
			fi
		done
		
		if [ $wine_pack = 0 ]; then
			cp -Rf wineversion/$wine_ver/ $wine_path/$ftp_elf
			if [[ -s $HOME/.winestarter/resources/ftp_$hq_ver.\[list\] ]]; then
				sed -ni "s/^\($wine_ver\)$/\1*/i;p" $HOME/.winestarter/resources/ftp_$hq_ver.[list]
			fi
		else
			mkdir -p $wine_path/$ftp_elf/$wine_ver/
			cp -Rf opt/wine-$hq_short/* $wine_path/$ftp_elf/$wine_ver/
			if [ $b_elf = 64 ]; then cd $wine_path/x86; ln -sf ../$ftp_elf/$wine_ver ; fi
			if [[ -s $HOME/.winestarter/resources/ftp_$hq_ver.\[list\] ]]; then
				sed -ni "s/^\($wine_ver\),\(.*\)$/\1*,\2/i;p" \
				$HOME/.winestarter/resources/ftp_$hq_ver.[list]
			fi
		fi
		cd $WINEVERPATH/bin
	fi
	
}
## environment settings (3)
fn_wine_binary(){
	if [ $_use_winepath_env -gt 0 ]; then
		wine_elf_path=$wine_path/$ftp_elf/$wine_ver
		export WINEVERPATH=$wine_elf_path
		export PATH=$wine_elf_path/bin:$PATH
		export WINESERVER=$wine_elf_path/bin/wineserver
		export WINELOADER=$wine_elf_path/bin/wine
		if [ $wine_elf = 1 ]; then
			export WINEDLLPATH=$wine_elf_path/$libs/wine/fakedlls
			export LD_LIBRARY_PATH=$wine_elf_path/lib:$wine_elf_path/$libs:$LD_LIBRARY_PATH
			#":/lib:/lib64:/usr/lib:/usr/lib64"
		else
			export WINEDLLPATH=$wine_elf_path/lib/wine
			export LD_LIBRARY_PATH="$wine_elf_path/lib:$LD_LIBRARY_PATH"
			#":/lib:/lib64:/usr/lib:/usr/lib64"
		fi
		wine_bin_path=$wine_elf_path/bin/
	## sandoxing wine by exec in WINELOADER directory
	cd $WINEVERPATH/bin
	fi
}
## winetricks dlls install module. (4)
fn_install_tricks(){
	unset diff_tricks
	w_list_file=$user_prefix/$bottle_prefix/winetricks.log
	w_tricks_reserve=$scpt_dir/resources/tricks_workaround.txt
	
	## winestarter has its own wintricks binary, but some weird thibgs happens some time, so
	## let's check if it is really in system tree, esle exit.
	if [[ -x $w_tricks ]]; then
	## set the dlls list to install.
		## check winetricks workaround list for winetricks log filtering
		if ! [[ -s $w_tricks_reserve ]]; then
			$w_tricks settings list|sed -n "/^---/,/---$/d;p"| egrep -v "^Using.*$"|awk '{print $1}' \
			>$w_tricks_reserve
		fi
		## set filters from winetricks settings list command.
		w_filters=$(cat $w_tricks_reserve| tr '\n' '|')'w_workaround'
		tmp_log=$(mktemp --tmpdir log1.XXXXXXXX)
		## set w_tricks_list readable for diff.
		_w_tricks_list=$(echo "$w_tricks_list"| tr ',' '\n')

		if [[ -s $w_list_file ]]; then
			## sort winetricks log alphabetiquely to avoir mistakes, if any.
			_w_list_file=$(cat $w_list_file| egrep -v "$w_filters")
			echo "$_w_list_file"| sort -bd >$tmp_log
			if [ $(echo "$_w_tricks_list"| grep -c .) -gt 0 ]; then
				## find diff between w_tricks_list and already installed.
				diff_tricks=$(echo "$_w_tricks_list"| grep -vFf "$tmp_log")
				if [[ $diff_tricks ]]; then
					w_tricks_loop=( $diff_tricks )
					if_diff=1
				else
					w_tricks_loop=''
					if_diff=0
				fi
			fi
		else
			w_tricks_loop=( $(echo "$w_tricks_list"| tr ',' '\n') )
			if [ ${#w_tricks_loop[@]} -gt 0 ]; then if_diff=1; else if_diff=0; fi
		fi
		## look for cabextract first, mandatory for MS package extraction.
		if [[ -x $cab_bin ]]; then
		## now, let's do winetricks job
		## Check that tricks install process is set to 'on' and take w_install_tricks is not empty.
		## else, send error and exit.
			if [ $w_install_tricks -gt 0 ]; then
				if [ $if_diff = 1 ]; then
					if [ ${#w_tricks_loop[@]} -gt 0 ]; then
						## take care for all brend new install and already existant ones.
						if [[ -s $w_list_file ]]; then new_repo=0; else new_repo=1; fi
						e_text="$vb\\Winetricks is working$end"		
						(for w_list in "${w_tricks_loop[@]}"; do
							echo "# Installing $w_list"
							$w_tricks $w_tricks_opts $w_list
						done
			#				)| $yad_bin --width=250 --title "$w_title" --text-align=center --text="$e_text" \
			#				--window-icon=filesave --progress --pulsate --auto-close --no-buttons
						)| $zen_bin --width=250 --title="$w_title" --text="$e_text" \
						--window-icon=filesave --progress --pulsate --auto-close --no-cancel
						if [[ -s $w_list_file ]]; then
							## analyse winetricks log again to get newly installed dlls.
							cat $w_list_file| egrep -v "$w_filters"| sort -bd > $tmp_log
							## ensure all dlls are installed, else, display error/info message.
							diff_logs=$(echo "$_w_tricks_list"| grep -vFf "$tmp_log")
							## if diff_logs is not empty, something wrong happened.
							if [[ $diff_logs != '' ]]; then
								warn_msg=$(echo "$diff_logs"| tr '\n' ','| sed -n "s/,$//g;p")
								echo -e "»»»» DLLs install error. $warn_msg are missing or won't install.\n»»»» See config file w_tricks_list field or try to launch winestarter again."
								if [ $zen_bin ]; then
									text="$bf\\DLLs install error$end$vb.\n$warn_msg are missing or won't install.\nLook at $config_file or try to launch Winestarter again$end"
									dialog_list="gtk-close;$warning;4;4"; zen_warning
								fi
							else
							## if diff_logs is empty, all dlls are installed.
							## Make a diff now between all new and added dlls. 
								if [ $new_repo -eq 0 ]; then
									## treat w_list_file for newly install dlls from config.
									_new_tricks=$(cat $tmp_log| tr '\n' ','| sed -n "s/,$//p")
									sed -ni "s|^\(w_tricks_list\)=\".*\"$|\1=\"$_new_tricks\"|i;p" \
									$config_file
								fi
								sed -ni "s|^\(w_install_tricks\)=.*$|\1=0|i;p" $config_file
							fi
						fi
					fi
				else
					if [ $w_tricks_list ]; then
						echo -e "»»»» No diff between old and new.\n»»»» Passed."
						text="$bf\\No diff found between Winetricks log and conf$end$vb.\nFunction passed\n$end"
						if [ $zen_bin ]; then dialog_list="gtk-close;$warning;4;4"; zen_warning; fi
						sed -ni "s|^\(w_install_tricks\)=.*$|\1=0|i;p" $config_file
					else
						echo -e "»»»» Winetricks install list is empty.\n»»»» If empty, leave Winetricks dlls install set up to 0 when DLLs list is empty."
						text="$bf\\Winetricks install list is empty.$end$vb.\nDon't set up Winetricks dlls install when DLLs list is empty\n$end"
						if [ $zen_bin ]; then dialog_list="gtk-close;$warning;4;4"; zen_warning; fi
#						exit 0
					fi
				fi
			fi
		else
			echo -e "»»»» Cabextract binary not found in system tree. Install it first."
			text="$bf\\Cabextract binary not found in system tree.$end\n$vb\\Install it first.$end"
			if [ $zen_bin ]; then dialog_list="gtk-close;$warning;4;4"; zen_warning; fi
			exit 0
		fi
	else
		echo -e "»»»» Winetricks was not found, install it first."
		if [ $zen_bin ]; then
			text="$bf\\Winetricks was not found$end\n$vb\\Install it first$end"
			dialog_list="gtk-close;$warning;4;4"; zen_warning
		fi
		exit 0
	fi
}
## multi format executable installation. (5) 
fn_install_exe(){
	sub_download(){
		if [[ $w_download_dir != '' ]]; then dl_dir=$w_download_dir; else dl_dir=$XDG_DOWNLOAD_DIR; fi
		pack_name=$(printf "$pkgs"| sed -n "s/^.*\///p")
		if ! [[ -s $dl_dir/$pack_name ]]; then
			dl_installer=1
			fn_download_ui
		fi		
	}
	pkgs_log=$user_prefix/$bottle_prefix/packages.log
	if_install=1
	if [ "$w_exe_path" != '' ]; then
		msi=$(printf "$w_exe_path"| grep -c "\.msi")
		new_pkg=$(printf "$w_exe_path"| sed -n "s/^.*\///g;p")
		if  ! [[ -s $pkgs_log ]]||[ $(cat $pkgs_log| grep -wc "$new_pkg") -eq 0 ]; then 
			if [[ $w_exe_path =~ ^(http*|ftp*) ]]; then
				pkgs=$w_exe_path
				sub_download
				w_exe_path=$dl_dir/$pack_name
			fi
			if [ $msi = 0 ]; then
				$wine_bin $w_exe_path $w_exe_opts
			else
				$wine_bin msiexec \/i $w_exe_path $w_exe_opts
			fi
			echo "$new_pkg" >> $pkgs_log
		else
			echo -e "»»»» $new_pkg already installed, pass."
		fi
		fn_extract_lnk_file
		sleep 1
		abort=0
	fi
	if [ $(printf "$w_more_pkgs"| grep -c .) -gt 0 ]; then
		extra_log=$user_prefix/$bottle_prefix/extra_pcks.log
#		w_more_pkgs_list=( $(echo "$w_more_pkgs"| tr ',' '\n') )
		for pkg in ${w_more_pkgs[@]}; do
			msi=$(printf "$pkg"| grep -c "\.msi")
			prev_pck=$(echo -e "$pkg"| sed -n "s/^.*\///g;p")
			if ! [[ -s $extra_log ]]||[ $(cat $extra_log| grep -wc "$prev_pck") -eq 0 ]; then
				if [[ $pkg =~ ^(http*|ftp*) ]]; then
					pkgs=$pkg
					sub_download
					pkg=$dl_dir/$pack_name
				fi
				if [ $msi = 0 ]; then
					$wine_bin $pkg $w_exe_opts
				else
					$wine_bin msiexec \/i $pkg $w_exe_opts
				fi
				echo "$prev_pck" >> $extra_log
			else
				echo -e "»»»» $prev_pkg already installed, pass."
			fi
		done
		abort=0
	fi
	## zip file section.
	if [ $(printf "$w_install_zip"| grep -c .) -gt 0 ]; then
	## set functions used by section first.
		## alert on bd behaviour.
		warn_msg(){
			echo -e "»»»» WARNING: Archive looks like an installation dir only.\nExtracting in default download dir.\nThen, set up extra packages install."
			if [ $zen_bin ]; then
				text="$brf\\Archive seems to be an install dir only.$end$vb\nYou can choose between :\n - Extract and Install as an extra package\n - Cancel, package will be extrated in default downlaod dir under $w_install_dir name, but wont be install.$end"
				dialog_list="gtk-close;$warning;Extract & Install;Cancel"; zen_question
			fi
			if [ $? = 0 ]; then go_on=1; else go_on=0; fi
		}
		new_pkg=$(printf "$w_install_zip"| sed -n "s/^.*\///g;p")
		if [[ $w_install_dir ]]; then
			if [[ $w_install_dir =~ ^.*$USER ]]; then
				w_install_dir=$(echo -e "$w_install_dir"| sed -En "s|^.*drive_c/(.*)$|\1|p") 
			fi
			target_dir=$user_prefix/$bottle_prefix/drive_c/$w_install_dir
		else
			target_dir=$user_prefix/$bottle_prefix/drive_c/
			if [[ $w_install_zip =~ ^.*-.*$ ]]; then
				w_install_dir=$(echo "$w_install_zip"| sed -En "s|^(.*)-(.*)$|\1|;s|^.*/||g;p")
				target_dir=$target_dir$w_install_dir
			else
				if [[ -x $zen_bin ]]; then
					dir_text="$vb\\Please, select or create the target directory in C: drive.$end"
	#				w_install_dir=$($yad_bin --width=400 --title "$w_title" --form \
	#				--image=stock_dialog_question --window-icon=filesave --separator="" \
	#				--field="$dir_text":LBL '' --field="":CDIR "$target_dir")
					$zen_bin --width=400 --title "$w_title" --question --window-icon=$filesave \
					--ok-label='Select' --cancel-label='Cancel' --text="$dir_text"
					abort=$?
					if [ $? = 0 ]; then
						w_install_dir=$($zen_bin --title "$w_title" --window-icon=$filesave \
						--file-selection --filename=$target_dir --directory)
					fi
					target_dir=$w_install_dir
					w_install_dir=$(printf "$target_dir"| sed -n "s/^.*\///g;p")
				fi
			fi
		fi
		
		_archive_type=( zip tar rar 7z tar.7z exe )
		if  ! [[ -s $pkgs_log ]]||[ $(cat $pkgs_log| grep -wc "$new_pkg") -eq 0 ]; then
			mkdir -p $target_dir
			game_dir=$w_install_dir
		
			if [[ $w_install_zip =~ ^(http*|ftp*) ]]; then
				pkgs=$w_install_zip
				sub_download
				w_install_zip=$dl_dir/$pack_name
			fi
			######
			_archive_type=( zip tar rar 7z tar.7z exe )
			for _type in ${_archive_type[@]}; do
				check_type=$(printf "$w_install_zip"| egrep -oi "$_type$")
				case $check_type in
					'zip')
						auto=0; cd_to=0; cmd='unzip'; _opt_list='-l'
						_opt_ex0='-o'; _opt_ex1='-d'; _extra=''
					;;
					'rar')
						auto=0; cd_to=1; cmd='unrar'; _opt_list='lb'
						_opt_ex0='x -y -o+ -inul'; _opt_ex1=''; _extra=''
					;;
					'7z')
						auto=0; cd_to=1; cmd='7z'; _opt_list='l'
						_opt_ex0='x -y'; _opt_ex1=''; _extra=''
					;;
					'tar.7z')
						auto=0; cd_to=1; cmd='7z'; _opt_list='l'
						_opt_ex0='x -y -so'; _opt_ex1='|'; _extra=' tar xf -'
					;;
					'exe')
						auto=1; cd_to=0
						cmd="$wine_bin $w_install_zip $wine_opts"
					;;
				esac
#				fi
			done
			if [ $cd_to = 1 ]; then cd $target_dir; fi
			if [ $auto = 0 ]; then
				if [ $( $cmd $_opt_list $w_install_zip | egrep -ic "setup.exe") -gt 0 ]; then
					warn_msg
					target_dir=$XDG_DOWNLOAD_DIR/$w_install_dir
					mkdir -p $target_dir
					$cmd $_opt_ex0 $w_install_zip $_opt_ex1 $target_dir
					if [ $go_on = 1 ]; then
						setup_bin=$(ls -1 $target_dir/| egrep -i "setup.exe")
						if ! [ $setup_bin ]; then
							echo -e "»»»» WARNING: Setup.exe not found.\n»»»» You need to set the install executable manually and launch the script again."
							if [ $zen_bin ]; then
								text="$brf\\Setup.exe not found.$end$vb\nSorry, but you need to set the install executable manually and launch the script again.$end"
								dialog_list="gtk-close;$warning;4;4"; zen_warning
							fi
							exit 0
						fi
						w_more_pkgs=$target_dir/$setup_bin
						w_install_zip=''
						fn_install_exe
					fi
				else
					$cmd $_opt_ex0 $w_install_zip $_opt_ex1 $target_dir
				fi
			else
				$cmd
			fi
			echo "$new_pkg" >> $pkgs_log
			if [ $cd_to = 1 ]; then cd $WINEVERPATH/bin; fi
		else
			echo -e "»»»» $new_pkg already installed, pass."
		fi
		fn_extract_lnk_file
	fi
	if [ $(printf "$w_extra_script"| grep -c .) -gt 0 ]; then
		chmod 755 $w_extra_script
		cp -f $w_extra_script $user_prefix/$bottle_prefix/drive_c/Program\ Files"$w_elf_ext"/$game_dir/
	fi	
	if [ $abort = 1 ]; then
		echo -e "»»»» EXE path was not found.\n# Defining the right install executable path is mandatory.\n# EXIT.\n"
		if [ $zen_bin ]; then
			text="$brf\\EXE path was not found.$end$vb\nDefining the right install executable path is mandatory.\n\nEXIT.$end"
			dialog_list="gtk-close;$warning;4;4"; zen_warning
		fi
		exit 0
	else
		perl -ni -pe "s|(w_install_exe)=[0-9]|\1=0|i" $config_file
	fi
}
## target dir existence and desktop file sub process (6)
fn_game_dir_exist(){	
	fn_root_key
	## search if there any app path in "Program Files" or root. If none, link the predifine app dir if any.
	if [[ $game_path != '' ]]; then
		link=$(printf "$game_path"| sed -n "s/^.*\///g;p")
		_link_target_dir=$user_prefix/$bottle_prefix/drive_c/"$root_key"$link
		_link_target_path=$user_prefix/$bottle_prefix/drive_c/"$root_key"
		if ! [[ -d $_link_target_dir ]]; then
			ln -sf $game_path $_link_target_path
		fi
		## if target app exe path is not find or doesn't exist at this point, search and define.
		## and create a desktop file if needed.
		## FIXME ?? manage the double link by mistake?
		if [[ -L $_link_target_dir ]]; then
			if_install=0
			if ! [[ -x $_link_target_path/$game_dir/$game_exe ]]; then
				fn_extract_lnk_file
			else
				## control target path and desktop file. If none, create, else, pass.
				_target_exe=$game_exe
				_target_dir=$user_prefix/$bottle_prefix//drive_c/"$root_key"/$game_dir
				_target_path=$(printf "$_target_dir"| sed -En "s|^(.*)/(drive_c)/(.*)$|\1/dosdevices/c:/\3|p")
				_unix_path=$_target_dir/$_target_exe
				fn_convert_desktop_file
			fi
		fi
	fi
}
## pre process step for fn_game_dir_exist (6pre) 
fn_root_key(){
	## search where is the "Prgram Files" dir and type.
#	fn_root_key
#	if [[ $game_dir == '' && $game_exe == '' ]]; then
#		mkdir -p $user_prefix/$bottle_prefix/drive_c/Program\ Files"$elf_ext"
#	fi
	## find where is the exe file to define first application root key.
	if [[ $game_exe ]]; then
		bin_dir_target=$(find -L \
		$user_prefix/$bottle_prefix/drive_c/Program\ {Files,Files\ \(x86\)} -wholename "*$game_exe")
		if [[ -e $bin_dir_target ]]; then
			bin_elf_type=$(file $bin_dir_target)
			if [ $(printf "$bin_elf_type"| egrep -c "80386") -gt 0 ]; then
				if [ $wine_elf -gt 0 ]; then
					root_key='Program Files (x86)/'; sed_key='Files\ (x86)\/'
				else
					root_key="Program Files/"; sed_key='Files\/'	
				fi
			else
				if [[ "$bin_dir_target" =~ ^.*x86.*$ ]]; then
					root_key='Program Files (x86)/'; sed_key='Files\ (x86)\/'
				else
					root_key="Program Files/"; sed_key='Files\/'
				fi
			fi
		else
			bin_dir_target=$(find -L $user_prefix/$bottle_prefix/drive_c/ -wholename "*$game_exe")
			root_key=''; sed_key=''
		fi
	else
		game_exe='null'
		root_key=''; sed_key=''
	fi
	win_prog_file="$root_key"
}
## sub after fn_game_dir_exist or sub process step after fn_extract_lnk_file. (6bis)
fn_convert_desktop_file(){
	_sub_convert_desk(){
		## other vars defined for both conditions.
		d_emblem=$scpt_dir/emblems/wine_emblem.png
		d_png_dir=$scpt_dir/png
		l_icon_dir=$HOME/.local/share/icons/hicolor	
		## check if _desk var is set, no matter it is, it mean that a desktop file was search & found,
		## and tell also that a png file exist in default local icons path.
		if ! [[ -d $XDG_DESKTOP_DIR/$_desk ]]; then
			## list all app available icons and convert 256px one to usable format.
			_path_icons_list=( $(find $l_icon_dir -iname "$d_icon*") )
			for _png in ${_path_icons_list[@]}; do
				icon_def=$(printf "$_png"| egrep -o "(\s*[0-9]*x[0-9]*)")
				icon_rank=$(printf "$icon_def"| sed -n "s/^.*x//p")
				if [ -n $icon_rank ]; then
					icon_min=$((256-$icon_rank))
					if [ $icon_min -le 208 ]; then
						rank_list+=("$icon_rank")
					fi
				fi
			done
			if [ ${#rank_list[*]} -gt 0 ]; then
				# "0,64 1,48 2,128"
				scale_op=$(printf "%s\n" ${rank_list[*]}| sort -n| tail -1)
				scale=$scale_op'x'$scale_op
				d_icon_src=$l_icon_dir/$scale/apps/$d_icon.png
				$convert_bin $d_icon_src $d_emblem -scale $scale -composite $d_png_dir/$d_exec.png
			fi
		else
			## use wrestool with _dest_path to extract png and convert to usable format:
			## set the icon type to extract.
			ico_type=14
			# extract the icon from _dest_path and send it to default winestarter icon path.
			$wres_bin -x -t $ico_type -o $scpt_dir/icons $_unix_path
			# extract the png from the icon in multi definition format
			ico_def_list=('256' '128' '64' '48')
			for _def in ${ico_def_list[@]}; do
			# look for index for the asked definition
				index=$($icot_bin -l $scpt_dir/icons/$d_exec\_$ico_type\_*.ico| \
				grep "\(width=$_def\).*\(bit-depth=32\)"| sed -n "s/^.*--index=\([0-9]\).*$/\1/g;p")
				if [[ $index > 0 ]]; then
					$icot_bin -x -i $index -o $scpt_dir/png $scpt_dir/icons/$d_exec\_$ico_type\_*.ico
					png_file=$(ls -1 $scpt_dir/png/$d_exec\_$ico_type*\_$_def\x$_def*.png)
					icon_rank=$_def
					icon_min=$((256-$icon_rank))
					if [ $icon_min -le 208 ]; then
						rank_list+=("$icon_rank,$png_file")
					fi
				fi
			done
			if [ ${#rank_list[*]} -gt 0 ]; then
				# "0,64 1,48 2,128"
				upper_def=$(printf "%s\n" ${rank_list[*]}| sort -n| tail -1)
				_scale=$(printf "$upper_def"| cut -d',' -f1)
				_icon=$(printf "$upper_def"| cut -d',' -f2)
				scale=$_scale'x'$_scale
				d_icon_src=$_icon.png
				$convert_bin $_icon $d_emblem -scale $scale -composite $d_png_dir/$d_exec.png
				
			fi
		fi
		if [[ -s $d_png_dir/$d_exec.png ]]; then
			d_icon=$d_png_dir/$d_exec.png
		else
			d_icon=$d_png_dir/defaults/wine48w.png
		fi
		## 'd_name d_exec d_path d_icon dsk_name'
		dsk_fields="[Desktop Entry]\nEncoding=UTF-8
Name=$d_name\nComment=$d_name Winestarter managed
Exec=winestarter $_config\nPath=$d_path
StartupWMClass=$game_exe\nType=Application\nStartupNotify=true
Icon=$d_icon\nCategories=Applications;"
		echo -e "$dsk_fields" > $XDG_DESKTOP_DIR/$dsk_name
		chmod 755 $XDG_DESKTOP_DIR/$dsk_name
	}
	## modify and backup the desktop file
	## then now main app cariables are define, check is there is an appropriate desktop file to convert
	## or create a new one from scratch.
	if [[ -x $convert_bin ]]; then
#		if [ -x $_unix_path ]; then
#		test -x $_unix_path
		if [[ -x $_unix_path ]] ; then
			_desktop_file_list=( $(ls -1 $XDG_DESKTOP_DIR| egrep "(\s*.desktop$)") )
			_dsk_key=$(printf "$_target_exe"| sed -En "s|^(\w*.{5,15})(.*).exe|\1|;s|[ ]?$||p")
			_config=$(printf "$config_file"| sed -n "s/^.*\///g;p")
			## check if _dsk_key match something in desktop files path
			## if yes, check if path var is a wine cmdline or a winestarter one.
			## if winestrater's cmd, check that conf conf file is the good one. If wine's, then convert.
			if [ $(ls $XDG_DESKTOP_DIR/| egrep -c "$_dsk_key") -gt 0 ]; then
				for _desk in "${_desktop_file_list[@]}"; do
					if [ $(echo -e "$_desk"| egrep -c "$_dsk_key") -gt 0 ]; then
						## check if desktop file is already configured by winestarter or not.
						if [[ $(cat $XDG_DESKTOP_DIR/$_desk| \
						egrep -c "^Exec=.*$_dsk_key.*exe[.*$|$]") -gt 0 || \
						$(cat $XDG_DESKTOP_DIR/$_desk| egrep -c "^Exec=.*$_config$") -eq 0 ]]; then
							## defines appropriiate vars and convert.
							## save original desktop file to winestarter conf directory.
							cp -f $XDG_DESKTOP_DIR/$_desk $scpt_dir/desktop/
							## look for avialable data from dktop file.
							d_name=$(cat $XDG_DESKTOP_DIR/$_desk| sed -En "s|^(Name=)(.*)$|\2|p")
							d_exec=$game_exe
							d_path=$(cat $XDG_DESKTOP_DIR/$_desk| sed -En "s|^(Path=)(.*)$|\2|p")
							d_icon=$(cat $XDG_DESKTOP_DIR/$_desk| sed -En "s|^(Icon=)(.*)$|\2|p")
							dsk_name=$_desk
							if ! [[ $d_path ]]; then d_path="$_target_path" ; fi						
							echo "→→→→→→ convert existing desktop"
							_sub_convert_desk
						fi
					fi
				done
			else
			## if no match create a desktop file from scratch, with a set appropriate vars.
				d_name=$(printf "$game_exe"| sed -En "s/^(.*).(exe|EXE)/\1/p")
				d_exec=$game_exe
				d_path="$_target_path"
				d_icon=$scpt_dir/png/$game_exe.png
				dsk_name=$d_name.desktop
				echo "×××××× create desktop from raw"
				_sub_convert_desk
			fi
		fi
	fi
}
## sub step process after install or when usage of usage of extract app path. (5bis)
fn_extract_lnk_file(){
	_sub_selector_diplay(){
		unset _sel_list
		for _sel_key in "${select_list[@]}"; do
			_sel_list+=("false")
			_sel_list+=("$_sel_key")
			_sel_list+=( $(printf "$_sel_key"| \
			sed -En "s|^($user_prefix/$bottle_prefix/drive_c/)(.*)$|\2|p") )
		done
		## test lnk correspondance to present application
		_sel_path=$($zen_bin --width=600 --height=380 --title "$w_title" --list --radiolist \
		--window-icon=$filesave --ok-label='Select a file' --cancel-label='Cancel' \
		--text="$sel_text" --column "select" --column='full path' --column "executable" \
		--hide-column=2 "${_sel_list[@]}")
	}
	## file exist. Test to find lnk file first.
	if [ $if_install -gt 0 ]; then lnk_file=''; fi
	w_desktop=$(printf "$XDG_DESKTOP_DIR"| sed -n "s/^.*\///g;p")
	lnk_file=$(find -L $user_prefix/$bottle_prefix/drive_c/users/Public/$w_desktop/ -iname "*.lnk")
	if [[ -x $zen_bin ]]; then	
		## search and define app dir, path and exe.
		if ! [ "$lnk_file" ]; then
		## if lnk file doesn't exist, check for exe file in default install path.
			## build an exe list with windowws system exclusion list.
			exclude_dir='users'
			exclude_list='[Ww]indows|Explorer'
			## if app data come from fn_game_dir_exist, change app exe seek as appropriate.
			if [ $if_install -gt 0 ]; then
				app_exe_list=$(find -L $_link_target_path$game_dir -iname "*.exe")
			else
				## to restrict search, look in where exe could be, not where it could'nt.
				app_exe_list=$(find -L $user_prefix/$bottle_prefix/drive_c/ \
				-not \( -path $user_prefix/$bottle_prefix/drive_c/$exclude_dir -prune \) -iname "*.exe" | \
				egrep -v "$exclude_list")
			fi
			select_list=( $app_exe_list )
			sel_text="$bf\\Desktop LNK file not found$end\n
$vb\\Select the appropriate executable file in the list below. Choose wisely, it would define the app
executable and dirrectory for config file, and moreover, allowing to create the dedicate desktop file.$end
\n$nf\\CAUTION:$end$vn Be aware that some apps have their executables in some boot directory,
but have to chroot in the main directory to start (the preivous usualy).
In this case, you have to modify the config file manualy or with Winestarter_conf as needed.$end"
			_sub_selector_diplay
			if [ $? = 0 ]; then
				_dest_path=$_sel_path
				_target_exe=$(printf "$_dest_path"| sed -n "s|^.*/||g;p")
				_target_dir=$(printf "$_dest_path"| sed -n "s|/$_target_exe||p")
				_target_path=$(printf "$_target_dir"| \
				sed -En "s|^(.*)/(drive_c)/(.*)$|\1/dosdevices/c:/\3|p")
				_unix_path=$_dest_path
			fi
		else
			## in case 'find' command return more than one, display a zenity selector.
			if [ ${#lnk_file[@]} -gt 1 ]; then
				select_list=( $lnk_file )
				sel_text="$bf\\More than Desktop LNK found in path$end\n
$vb\\Select the appropriate LNK file in the list below.$end"
				_sub_selector_diplay
				if [ $? = 0 ]; then
					lnk_file=$_sel_path
				fi
			fi
			_dest_path=$($strings_bin $lnk_file| egrep "\s*(C:|Prog.*Files).*exe")
	#			_dest_path=$($strings_bin $lnk_file| egrep "\s*(C:).*exe")
			_target_exe=$($wine_bin winepath -u $_dest_path| sed -n "s/^.*\///g;p")
			_target_dir=$($wine_bin winepath -u $_dest_path| \
			sed -En "s|^(.*c:/)(.*)/($_target_exe)$|$user_prefix/$bottle_prefix/drive_c/\2|p")
			_target_path=$($wine_bin winepath -u $_dest_path| sed -En "s|^(.*c:/)(.*)/($_target_exe)$|\1\2|p")
			_unix_path=$_target_dir/$_target_exe
		fi
		if [[ $_target_dir =~ ^.*x86.*$ ]]; then
			sed_key='Files \(x86\)/'; else sed_key='Files/';
		fi
		game_dir=$(printf "$_target_dir"| sed -En "s|^.*$sed_key||p")
		game_exe=$_target_exe
	fi
	fn_convert_desktop_file
}
## debug dialog options (7)
fn_wine_dbg(){
	if [ $_extended -gt 0 ]; then
		dbg_reg_hd='REGEDIT4\n\n[HKEY_CURRENT_USER\Software\Wine\WineDbg]'
		## prepare reg headers.
		echo -e "$dbg_reg_hd" > $user_prefix/$bottle_prefix/dbg_reg.reg
		## if set; loop and create insertion text.
		dbg_list=('dbg_dialog,ShowCrashDialog' 'dbg_handle,BreakOnFirstChance')
		## define updating rank to 0 for next conditionnal request compatibilty.
		_updating=0
		for _dbg_val in ${dbg_list[@]}; do
			dbg_name=$(printf "$_dbg_val"| cut -d',' -f1)
			dbg_keyword=$(printf "$_dbg_val"| cut -d',' -f2)
			eval _val_set="$"$dbg_name
			if [ $_val_set -gt 0 ]; then _val_set=0; else _val_set=1; fi
			dbg_dword=$_val_set
			reg_line="\"$dbg_keyword\"=dword:0000000$dbg_dword"
			## check if value is already set.
			if [ $(cat $user_prefix/$bottle_prefix/user.reg| grep -c "$reg_line") -eq 0 ]; then
				echo -e "\"$dbg_keyword\"=dword:0000000$dbg_dword"| tee -a \
				$user_prefix/$bottle_prefix/dbg_reg.reg
				((_updating++))
			fi
		done
		## if value are updated or sipmly sets, start regedit.
		if [ $_updating -gt 0 ]; then
			$wine_bin regedit $user_prefix/$bottle_prefix/dbg_reg.reg
			notify-send -t 2800 "Reloading WineDbg with new settings"
			$wineboot_bin -r
			$wineserver_bin -k
		fi
	fi
}
## additional function for wine process (8)
fn_regedit(){
	if ! [[ -e $user_prefix/$bottle_prefix/$reg_file ]]; then
		printf "REGEDIT4\n\n$user_reg\n" > $user_prefix/$bottle_prefix/$reg_file
		if [[ $(cat -n $user_prefix/$bottle_prefix/$reg_file| grep -c .) -ge 3 ]]; then
			$wine_bin regedit $user_prefix/$bottle_prefix/$reg_file
			notify-send -t 2800 "Reloading register with new settings"
			$wineboot_bin -r
			$wineserver_bin -k
		else
			IFS=$ifs ; exit 0
		fi
	else
		previous_reg=$user_prefix/$bottle_prefix/$reg_file
		printf "REGEDIT4\n\n$user_reg\n" > $user_prefix/$bottle_prefix/$reg_file.new
		new_reg=$user_prefix/$bottle_prefix/$reg_file.new
		
		if [ $(diff -q $previous_reg $new_reg| grep -c .) -gt 0 ]; then
			if [ $(cat $user_prefix/$bottle_prefix/$reg_file.new| grep -c .) -gt 0 ]; then
				printf "REGEDIT4\n\n$user_reg\n" > $user_prefix/$bottle_prefix/$reg_file			
				$wine_bin regedit $user_prefix/$bottle_prefix/$reg_file
			else
				$wine_bin regedit -D HKEY_CURRENT_USER\\Software\\Wine\\Direct3D
				printf "" > $user_prefix/$bottle_prefix/$reg_file
			fi
			notify-send -t 2800 "Reloading register with new settings"
			$wineboot_bin -r
			$wineserver_bin -k
		fi
		rm -f $user_prefix/$bottle_prefix/$reg_file.new
	fi
}
fn_mime_asso(){ ## (9)
	## convert conf coma separated data in usable list.
	mime_type_list=( $(printf "$local_association"| tr ',' '\n') )
	if [ ${#mime_type_list[@]} -gt 0 ]; then
	mime_log=$user_prefix/$bottle_prefix/mime_install.log
	## create temp file only if type list is not empty.
	reg_temp=$(mktemp --tmpdir mime.XXXXXXXX)
	## loop on conf list, check and set if available.
		for type in ${mime_type_list[@]}; do
			mime_def=$(cat $scpt_dir/resources/mime-type.lst| grep "^$type")
			if [ $(printf "$mime_def"| grep -c .) -gt 0 ]; then
				file_type=$(printf "$mime_def"| cut -d':' -f1)
				doc_type=$(printf "$mime_def"| cut -d':' -f2)
				mime_type=$(printf "$mime_def"| cut -d':' -f3)
				## controL if file type is not already setted
				if [ $(cat $mime_log| grep -c "^$file_type") -eq 0 ]; then
					## create the reg file from the collected vars
					reg_base="REGEDIT4

[HKEY_CLASSES_ROOT\\.$file_type]
@=\"$doc_type\"
\"Content Type\"=\"$mime_type\"
[HKEY_CLASSES_ROOT\\$doc_type\\Shell\\Open\\command]
@=\"winebrowser \\\"%1\\\"\""
					echo "$reg_base" &> $reg_temp
					## launch wine regedit on reg temp file setted.
					$wine_bin regedit $reg_temp
					## send newly installed report to bottle mime install log
					printf "$file_type,$doc_type\n" >> $mime_log
					## wipe and go to the next loop variable.
				fi
			fi
		done
		notify-send -t 2800 "Reloading Wine with new mime types"
		$wineboot_bin -r
		$wineserver_bin -k
		rm -f $reg_temp
	fi
}
fn_reg_dlls(){ ## (10)
	if [[ "$dll_reg_manager" ]]; then
		if [ $(printf "$dll_reg_manager"| grep -c .) -gt 0 ]; then
			reg_type=$(printf "$dll_reg_manager"| cut -d',' -f1)
			reg_elf=$(printf "$dll_reg_manager"| cut -d',' -f2)
			reg_dlls=$(printf "$dll_reg_manager"| cut -d',' -f3-)
			if [ $reg_type = 1 ]; then reg_opt='/u'; else reg_opt=''; fi
			if [ $elf = 64 ]; then
				if [ $reg_elf = 2 ]; then
					reg_sys=("system32" "syswow64")
				else
					if [ $reg_elf = 0 ]; then reg_sys=("syswow64"); else reg_sys=("system32"); fi
				fi
			else
				if [ $reg_elf -gt 0 ]; then	
					echo "# Wrong system arch. DLLs will be registered to 32bits."
				fi
				reg_sys=("system32")
			fi
			reg_log=$user_prefix/$bottle_prefix/dlls_reg.log
			reg_dlls=( "$(echo "$reg_dlls"| tr ',' '\n')" )
			if ! [[ -s $reg_log ]]; then touch $reg_log; fi
			for t_arch in ${reg_sys[@]}; do 
				for t_dll in ${reg_dlls[@]}; do
					if [ $(cat $reg_log| egrep -c "$t_arch,$t_dll" ) -eq 0 ]; then
						printf "$t_arch,$t_dll\n" >> $reg_log
						$wine_bin regsvr32 $reg_opt C:\\windows\\$t_arch\\$t_dll
					fi
				done
			done
			notify-send -t 2800 "Reloading Wine with new dlls settings"
			$wineboot_bin -r
			$wineserver_bin -k
		fi
	fi
}
## other sub process. (11)
fn_wineconf(){
	winecfg
	perl -ni -pe "s|(w_config)=[0-9]|\1=0|i" $config_file
	notify-send -t 2800 "Reloading Wine with new winecfg settings"
	$wineboot_bin -r
}
## managed app and wine pids discovering. (12)
fn_wine_kill(){
	sub_kill(){
#		unset _pid_list
#		line=52
		if [ $disfunct -gt 1 ]; then
			text="$bf\\$game_exe is gone ZOMBIE$end\\n
$vb\\Nothing to do except kill the beast. Select app pid in list and kill it,
or use safe mode and select Wine processes and kill them all at once.$end"
		else
			text="$bf\\$app_name seems buggy and WineDbg is running$end\\n
$vb\\$app_name could start normally or not. If you feel unsafe, keep this window open. 
This way, you will be allowed to kill it any time properly if something goes wrong.$end
$nf\\Note:$end$vn You can kill only app pid, but safe mode is to select Wine processes and kill them all at once
because Wineserver doesn't always receive the app term signal.$end"
		fi
		_pid_list=( $(ps --ppid=$wine_grp -o pid,cmd | \
		sed -En "s/^[ ]?([0-9]{4,5}) ((.*\.exe[]]? .*)|(C:.*)|(.*wineserver.*))$/\1 \2/p") )
		while [ $(ps --ppid=$wine_grp -o cmd| grep -c "winedbg") -gt 0 ]; do
			sleep 5
		done
		if [ $(ps -f --ppid=$wine_grp -o cmd | grep -c "$pid_short_name.*.exe") -gt 0 ]; then
#			unset zen_list pid_to_kill
			if [ $(ps --pid $wineserver_pid| grep -c .) -gt 1 ]; then
				for pid_line in "${_pid_list[@]}"; do
					zen_list+=("false")
					zen_list+=( $(echo "$pid_line"| sed -En "s/^[ ]?([0-9]{4,5}) (.*)$/\1/g;p") )
					zen_list+=( $(echo "$pid_line"| sed -En "s/^[ ]?([0-9]{4,5}) (.*)$/\2/g;p") )
				done
#				height=420
				_pid_to_kill=$($zen_bin --width=600 --height=400 --title="winestarter apps pids" \
				--window-icon=  --text "$text" --list --checklist --multiple \
				--column "select" --column "pid" --column "command" --separator="," "${zen_list[@]}" )
				if [ $? -eq 0 ]; then
					pid_to_kill=( $(echo "$_pid_to_kill"|sed -n "s/,/\n/g;p") )
					if [[ $_pid_to_kill ]]; then
						for kills in "${pid_to_kill[@]}"; do
							kill -9 $kills
						done
					fi
				fi
			fi
		fi
	}
	wine_grp=$(ps -A -f | grep wineserver | grep -v "pts"| awk '{print $3}'| sed -n '1p')
#	grp_id_key=$(ps -A -f | grep wineserver | grep -v "pts"| awk '{print $2}'| sed -En "s/^(.{1}).*$/\1/p")
	wineserver_pid=$(ps --ppid=$wine_grp -o pid,cmd | grep "wineserver"| awk '{print $1}')
	pid_short_name=$(printf "$game_exe_only"| sed -En "s/^(.{3}).*/\1/g;p")
	#	n=1
	## if app crash, wineserver is usally still running. Detect winserver pid to check that anything goes 
	## wrong. If it is the case, display a pid list to kill proberly the buggy app.
	app_name=$(printf "$game_exe_only"| sed -n "s/\.exe//g;p")
	until [[ $(pidof -s winedgb) ]]; do
		## count 10 second then exit to next step.
		_dbg_pid=$(ps --ppid=$wine_grp -o cmd| grep -c "winedbg")
		((c++)) && if [ $_dbg_pid -eq 0 ]; then ((c==7)); else break; fi && break
		sleep 1
	done
#	if [ $(ps --ppid=$wine_grp -o cmd| grep -c "winedbg") -gt 0 ]; then
	if [ $_dbg_pid -gt 0 ]; then
		sub_kill
	fi

	if [ $(ps -f --ppid=$wine_grp -o cmd | grep -c "$pid_short_name.*.exe") -gt 0 ]; then
		while [[ $(ps -f --ppid=$wine_grp -o pid,cmd | grep "$pid_short_name.*.exe"| awk '{print $1}') ]]; do
			## ps --ppid=2853 -o state,cmd | sed -En "s/^([A-Z]) (.*\.exe[]]?[ ]?.*)$/\1 \2/p"
			disfunct=0
			if [[ $(pidof -s winedgb) ]]; then disfunct=1; fi
			if [[ $(ps --ppid=$wine_grp -o state,cmd | egrep -cE  "^Z .*\.exe[]]?[ ]?.*$") -gt 0 ]]; then
				disfunct=2
			fi
			if [ $disfunct -gt 0 ]; then sub_kill; fi
			app_pid=$(ps -f --ppid=$wine_grp -o pid,cmd | grep "$pid_short_name.*.exe"| awk '{print $1}')
			sleep 10
		done
		if [ $(ps --pid $app_pid| grep -c .) -gt 1 ]; then kill $app_pid; fi
	fi
	IFS=$ifs
	## if replace window manager or xrandr is set, don't kill before app is properly killed.
	if [ $set_desktop_env -gt 0 ]; then
		$default_desktop --replace &
	fi
	if [ $auto_set -gt 0 ]; then ${bck_xrandr}; fi
	## restore linux regex
	IFS=$ifs
	exit 0
}
fn_replace_env(){
	sec_desk=$(find /usr/{bin,local/bin} -name $secondary_desktop)
	if [[ -x $sec_desk ]]; then
		$secondary_desktop --replace &
	fi
}
## functions are placed in order of execution; functional schemas:
##	fn_wipe_cache
##	fn_optimus
##	fn_use_winepath > fn_download_ui
##	fn_wine_binary
##	fn_install_tricks
##	fn_install_exe > fn_download_ui >fn_extract_lnk_file > fn_convert_desktop_file
##	fn_root_key > fn_game_dir_exist > fn_convert_desktop_file
##	fn_wine_dbg
##	fn_regedit
##	fn_mime_asso
##	fn_reg_dlls
##	fn_wineconf
##	fn_wine_kill > fn_replace_env
cd $scpt_dir
## memory cache overload control and wipe if necessary
if [ $cache_wipe -gt 0 ]; then fn_wipe_cache; fi
## set xrandr if necessary
if [ $auto_set -gt 0 ]; then
	${set_xrandr}
	sleep 3
fi
## make unix space behaviour redeable
ifs=$IFS
IFS=$(echo -en "\n\b")
if [ $wine_elf = 1 ]; then
	elf=64; elf_ext=' (x86)'; w_elf_ext='\ (x86)'; ftp_elf='amd64'; libs="lib$elf"
else
	elf=32; elf_ext=''; w_elf_ext=''; ftp_elf='x86'; libs='lib'
fi
## export env variable, usually "env WINEARCH=wine32 WINEPREFIX=~/wine_prefix" before wine cmd 
export WINEARCH=win$elf
#export WINEARCH=win64
export WINEPREFIX=$user_prefix/$bottle_prefix
_use_winepath_env=0
if [ $use_optimus = 1 ]; then fn_optimus; fi
if [ $use_winepath = 1 ]; then fn_use_winepath; fi
fn_wine_binary
#if [ $w_install_tricks = 1 ]; then fn_install_tricks; fi
fn_install_tricks
if [ $w_install_exe = 1 ]; then fn_install_exe; fi
fn_game_dir_exist

## set windowed mode if checked.
winestarter_reg=$user_prefix/$bottle_prefix/winestarter.reg
default_reg=$user_prefix/$bottle_prefix/user.reg
if [ $windowed -gt 0 ]; then
#	cd $WINEVERPATH/bin
#	[[ -s $winestarter_reg ]]|| touch $winestarter_reg	
	if [[ $(cat $default_reg| egrep -c "\"Desktop\"=\"Default\"") -eq 0 ]]; then
		## find primary display res.
		current_res=$(xrandr --current| fgrep "*"| awk '{print $1}')
		desktop_color='0 0 0'
		starter_reg="[HKEY_CURRENT_USER\Software\Wine\\\\Explorer]
\"Desktop\"=\"Default\"
[HKEY_CURRENT_USER\Software\Wine\\\\Explorer\Desktops]
\"Default\"=\"$current_res\"
[HKEY_CURRENT_USER\Control Panel\Colors]
\"Background\"=\"$desktop_color\""
		printf "REGEDIT4\n\n$starter_reg\n" > $winestarter_reg
#		$wine_bin regedit $winestarter_reg
		if [[ -s $winestarter_reg ]]; then
			sleep 1
			$wine_bin regedit $user_prefix/$bottle_prefix/winestarter.reg
#			$wine_bin regedit winestarter.reg
			notify-send -t 3000 "Reloading Wine with new display settings"
			$wineboot_bin -u
			$wineserver_bin -k
			
		fi
	fi
else
	if [[ $(cat $default_reg| egrep -c "\"Desktop\"=\"Default\"") -gt 0 ]]; then
		$wine_bin regedit -D HKEY_CURRENT_USER\\Software\\Wine\\Explorer
		notify-send -t 2800 "Reloading Wine with no display settings"
		$wineboot_bin -u
		$wineserver_bin -k
	fi
fi
## Wine Dbg behaviour options and management
fn_wine_dbg
reg_file=$(printf "$conf"| sed -n "s/\.conf//p")".reg"
## create and insert registry entry if any.
fn_regedit
if [ $(printf "$local_association"| grep -c .) -gt 0 ]; then fn_mime_asso; fi
if [ $(printf "$dll_reg_manager"| grep -c .) -gt 0 ]; then fn_reg_dlls; fi
if [ $w_config = 1 ]; then fn_wineconf ; fi

## check one last time that appli directory exist
if ! [[ -s $user_prefix/$bottle_prefix/drive_c/"$root_key"$game_dir/$game_exe ]]; then
	IFS=$ifs 
	echo -e "»»»» Can't find $game_exe for $user_prefix/$bottle_prefix
»»»» ABORT & EXIT"
	if [[ $zen_bin ]]; then
		text="$bf\\Can't find an executable for:$end\n$brf\\$user_prefix/$bottle_prefix$end\n\n$vb\\Script will now end on exception.$end"
		dialog_list="gtk-close;$warning;4;5"; zen_warning
	fi
	exit 0
fi

if [ $set_desktop_env = 1 ]; then fn_replace_env; fi
## test to find out the real application path
if [[ -d $user_prefix/$bottle_prefix/drive_c/$game_dir ]]; then
	win_prog_file=''
else
	win_prog_file="$root_key"
fi
## capture app exe for pid discovering and before cmd line conversion
export game_exe_only=$(echo "$game_exe"| perl -pe "s/^.*\///p")
if [ $special_cmd -gt 0 ]; then
	cd $user_prefix/$bottle_prefix/drive_c/"$root_key"$game_dir
	## xhange wine_bin to full path
	wine_bin=$wine_bin_path$wine_bin
	$opti_run $wine_bin $game_exe $wine_opts &
elif [ $start_cmd -gt 0 ]; then
	# pull wine start command line in unix syle
	$opti_run $wine_bin start /unix \
	"$user_prefix/$bottle_prefix/drive_c/"$root_key"$game_dir/$game_exe" $wine_opts &
else
	## Replace Linux slash by Windows backslash
	$wine_bin --version
	SOFT_PATH=$($wine_bin winepath -w "$user_prefix/$bottle_prefix/drive_c/"$win_prog_file"$game_dir/$game_exe")
	$opti_run $wine_bin $SOFT_PATH $wine_opts &
fi
## find .exe pid file and let some time for exe too launch before
#sleep 10
## if script is launched from winestarter configurator, get Yad pid and kill it
if [[ $(pidof yad) ]]; then killall -15 yad ; fi
#if [[ $bck_xrandr ]]; then export bck_xrandr=$bck_xrandr; fi
## Script wont send started app îd to system before bash code exit.
## To prevent this launch pid manager and tester out of the box. 
fn_wine_kill &
## restore linux regex
IFS=$ifs
exit 0
