#! /bin/bash

# #License:
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public
#   License as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later
#   version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public
#   License along with this program.  If not, see
#   <https://www.gnu.org/licenses/>.
#
## You can redistribute it as you wish : GPL v3
## author : wildtruc@noneltd.net

#PATH=$PATH
colors(){
if [ -s $HOME/.winestarter/color.conf ]; then
 . $HOME/.winestarter/color.conf
fi
vb='<span color="'$main'" weight="bold" font="'$font0' '$size0'">'
vn='<span color="'$main'" weight="normal" font="'$font0' '$size0'">'
rb='<span color="'$warn'" weight="bold" font="'$font0' '$size0'">'
gb='<span color="'$freeze'" weight="bold" font="'$font0' '$size0'">'
bf='<span color="'$main'" weight="bold" font="'$font1' '$size1'">'
brf='<span color="'$warn'" weight="bold" font="'$font1' '$size1'">'
#bf='<span color="'$main'" weight="bold" font="'$font' '$(($size+4))'">'
#brf='<span color="'$warn'" weight="bold" font="'$font' '$(($size+4))'">'
nf='<span weight="bold" font="'$font0' '$size0'">'
vz='<span color=\"'$main'\" weight=\"bold\" font=\"'$size0'\">'
end='</span>'
## Script colours Vars.
#t='\e[0;39m'	#default terminal colour
#r='\e[1;31m'	#red
g_notif='\e[1;31m'	#green
c_notif='\e[1;32m'	#cyan
#j='\e[1;33m'	#yellow
i_notif='\e[40m\e[1m\e[37m''\e[1;31m'
e_notif='\e[0;39m'
}
icons_set(){
	png_stock=$HOME/.winestarter/png/defaults
	## window bar icon
	img_desktop=$png_stock/'wine48w.png'
	
	img_wine_add=$png_stock/'new_bottle16.png'
	img_wine_mod=$png_stock/'config16.png'
	img_wine_desk_bt=$png_stock/'desktop16.png'
	img_wine_desk_ui=$png_stock/'wine48w.png'
	img_wine_ui=$png_stock/'wine-wine48.png'
	img_wine_desktop=$png_stock/'colors48.png'
	img_wine_cfg1=$png_stock/'wine-winecfg48.png'
	img_wine_cfg2=$png_stock/'wine-msiexec48.png'
	img_wine_opts=$png_stock/'colors48.png'
	img_tricks=$png_stock/'wine-winetricks48.png'
	img_tricks_bt=$png_stock/'wine16w.png'
	img_install=$png_stock/'wine-install48.png'
	img_reged=$png_stock/'wine-winefile48.png'
	img_nv_cm=$png_stock/'nvidia48.png'
	img_nv_ext=$png_stock/'graphic_set48.png'
	img_xrandr=$png_stock/'display48.png'
	img_opti=$png_stock/'optimus48.png'
	img_wine_colors=$png_stock/'colors16.png'
	img_wine_restart=$png_stock/'reload.png'
	img_wine_reload=$png_stock/'reload48.png'
	## PoL and WineHQ selection and download set
	img_winepol_bt=$png_stock/'playonlinux16.png'
	img_winedis_bt=$png_stock/'wine16r.png'
	img_dl_pol=$png_stock/'wine48w.png'
	img_dl_whq=$png_stock/'wine48r.png'
}
main_code(){
		default_win_design(){
		echo -e "$i_notif\n@@@@ default_win_design @@@@\n$e_notif"
		## reset IFS to include white space
		ifs=$IFS
		IFS=$(echo -ne "\n\b")
		## reset field values
		unset field_list chk_list
		## common sets values are represented under this form:
		## base form : 
		## 1/ input var data (and extended data for combo);
		## 2/ input var name;
		## 3/ tab title (for fn_create_prefix);
		## 4/ field message and information;
		## 5/ field class (CHK,LBL,CB,etc); 
		## 6/ function name (for fn_create_prefix and tab creation);
		## 7/ section tab left side image 
		## >> "TRUE;\2;\3;\4;\5;\6;\7"
		## and catch by the following regex:
		regex_0='^0;(.*;CHK;.*)'
		regex_1='^1;(.*;CHK;.*)'
		regex='(.*);(.*);(.*);[ ]?(.*);([A-Z]{0,4});(.*);(.*)'
		## convert CHK numeric values to TRUE/FALSE
		basic_sets=$(echo "$basic_sets" | sed -E -n "s/$regex_0/FALSE;\1/i;p"| \
		sed -E -n "s/$regex_1/TRUE;\1/i;p")
		
		## fields and corresponding values are then all parsed at the same time and displayed faster.
		field_list=$(echo "$basic_sets" | sed -E -n "s/$regex/--field=\4:\5/p")
		chk_list=$(echo "$basic_sets"| sed -E -n "s/$regex/\1/p" | \
		sed -E -n "s/^([0-9],[0-9],[0-9].*)$/\1,unset/i;p")

		# sortie : ';;TRUE;TRUE;FALSE;TRUE;TRUE;;;FALSE;FALSE;;;TRUE;FALSE;;;;FALSE;'
		# origin regex form: regex='(.*);(.*);(.*);[ ]?(.*);([A-Z]{2,4});(.*);(.*)'
		# corresponding to : "TRUE;\2;\3;\4;\5;\6;\7"
		## extract basic_sets data without labeled line and get exploitable datas only.
		from_basic=$(echo "$basic_sets"|	 egrep -v 'LBL'| sed -E -n "s/$regex/\1;\2;\3;\6;\7/p")

		# ne pas tenir compte des labels
		if [ $win_type = 0 ]; then
			def_win=$($yad_bin --width=$w_width --title "$w_title" --image=$img_wine_ui \
			--window-icon=$img_desktop --form --separator=';' --item-separator="$item_sep" \
			--align=left --text "$bf$w_text$end" $(echo "$field_list") $(echo "$chk_list") )
			if [ $? = 1 ]; then exit 0; fi
			from_output=$(echo "$def_win"| sed -n "s/;/\n/g;p"| cat -b| awk 'NF'| \
			sed -E -n "s/^.*\ ([0-9]{1,3})\t(.*$)/\1#\2/;s/TRUE/1/g;s/FALSE/0/g;p")
		fi
		if [ $win_type = 1 ]; then
			## fields and corresponding values are then all parsed at the same time and displayed faster.
			field_list=( $(echo "$basic_sets" | sed -E -n "s/$regex/--field=\4:\5/p") )
			chk_list=( $(echo "$basic_sets"| sed -E -n "s/$regex/\1/p" | \
			sed -E -n "s/^([0-9],[0-9],[0-9].*)$/\1,unset/i;p") )
		
		
			## extract basic_sets data without labeled line and get exploitable datas only. 
			echo "$basic_sets"| egrep -v "LBL|FBTN"| sed -E -n "s/$regex/\1;\2;\3;\6;\7/p" > $temp_a
			echo -e "$g_notif >>>> CHECK ME$e_notif"

			w_width=$((594+$scale))
			$yad_bin --width=$w_width $t_plug $t_rank $t_icon --text="$w_text" \
			$extend_height $extend_pol --form --separator=';' --item-separator="$item_sep" $focus \
			"${field_list[@]}" "${chk_list[@]}" > $temp_b &
		fi
#		if [ $win_type = 2 ]; then
#			"${field_list[@]}" "${chk_list[@]}"
#		fi

		## restore IFS to previous state
		IFS=$ifs
		## from here, yad window is waiting for validation to go to next process.
		echo -e "$g_notif\n>>>> $temp_a\n>>>> $(cat $temp_a)$e_notif"
		echo -e "$g_notif\n>>>> $temp_b\n>>>> $(cat $temp_b)$e_notif"
	}
		default_tab_design(){
		echo -e "$i_notif\n@@@@ default_tab_design @@@@\n$e_notif"
		wait_message='CREATE UI'
		fn_plz_wait &
		WAIT_UI_1=$(ps -A | grep "yad" | awk '{print $1}'| sed -n '1p')
#		n_cfg=1
		_num_tab=1 
		
		## This, represent only window tab order and making.
		## compare input and output datas.
		## redefine regex for new output form.
		## output data to be treated are represented under this form : 
		## 1/ output var data;
		## 2/ input>output var name;
		## 3/ tab title (for fn_create_prefix);
		## 6/ function name (for fn_create_prefix and tab creation);
		## 7/ section tab left side image
		regex='(.*);(.*);(.*);(.*);(.*)'
		### valeur spÃ©cifiques
		for _out_var in ${from_output}; do
			_line=$(printf "$_out_var"| cut -d'#' -f1)
			_val=$(printf "$_out_var"| cut -d'#' -f2)
			if [[ $_val =~ TRUE|FALSE ]]; then
				if [[ $_val == 'TRUE' ]]; then _val=1; else _val=0; fi
			fi
			if [ $(printf "$_line"| grep -c .) -gt 0 ]; then
				## extract variable value by emulating cut.
				_out_var=$(echo "$from_basic"| sed -n $_line\p| sed -E -n "s/$regex/\2/p" ) #/2
				if [ $_val -gt 0 ]; then
					## define if the basic_sets come from initial tab creation or not.
					if [ $(echo "$from_basic"| sed -n $_line\p| \
					sed -E -n "s/$regex/\3/p"| grep -c .) -gt 0 ]; then
						_out_tab=$(echo "$from_basic"| sed -n $_line\p| sed -E -n "s/$regex/\3/p" ) #/3
						_out_fun=$(echo "$from_basic"| sed -n $_line\p| sed -E -n "s/$regex/\4/p" ) #/4
						_out_img=$(echo "$from_basic"| sed -n $_line\p| sed -E -n "s/$regex/\5/p" ) #/5
						## prepare tab values per section and add them to tab list.
						tab_set+=("$_num_tab;$_out_var;$_out_tab;$_out_fun;$_out_img")
						## increment by 1 at each loop.
						_num_tab=$[ $_num_tab+1 ]
					fi
				else
					_val=0
				fi
			fi
			## independently of any previous filters, sent output var to local script environment.	
			if [[ $_out_var == _extended ]]; then
				export $_out_var=$_val 
			else
				local $_out_var=$_val
			fi
			echo -e "$g_notif\n>>>> tab_set \n>>>> ${tab_set[@]}$e_notif"
		done
		
	}
	default_tab_create(){
		echo -e "$i_notif\n@@@@ default_tab_create @@@@\n$e_notif"
		## after each tab lists are defined, analyse them by loop to create corresponding window tabs.
		## cycle between each defined tabs to prepare their temp files 
		for tab_vars in ${tab_set[@]}; do
			## extract all vars from tab_set list.
			t_num=$(printf "$tab_vars"| cut -d';' -f1)
			t_var=$(printf "$tab_vars"| cut -d';' -f2)
			t_name=$(printf "$tab_vars"| cut -d';' -f3)
			t_fn_op=$(printf "$tab_vars"| cut -d';' -f4)
			t_img=$(printf "$tab_vars"| cut -d';' -f5)			
			## if tab number is not null create corresponding temp files and fields data.
			if [ $t_num -gt 0 ]; then 
				temp_a=$(mktemp --tmpdir tab$t_num.a.XXXXXXXX)
				temp_b=$(mktemp --tmpdir tab$t_num.b.XXXXXXXX)
				tmp_key_a=$(printf "$temp_a"|sed -n "s|^.*\.||p")
				tmp_key_b=$(printf "$temp_b"|sed -n "s|^.*\.||p")
				t_plug="--plug=$key"
				t_rank="--tabnum=$t_num"
				t_icon="--image=$t_img"
				t_name=$(printf "$t_name"| tr '*' ' ')
				t_display+=("--tab=$t_name")
				
				t_val=1
			else
				t_val=0
			fi
			## add/create window tab data to be listed in extract_tmp_settings section.
			tab_temp+=("$t_var;$t_val;$t_name;$temp_a;$temp_b;$tmp_key_a;$tmp_key_b")
			echo -e "$g_notif\n>>>> tab temp\n>>>> ${tab_temp[@]}$e_notif"
			## if specific function is associated, execute it to get datas.
			## each time a tab is assigned, start associated function to load tab content in temp files.
			if [ $t_num -gt 0 ]; then ${t_fn_op}; fi ## <<<< SOOOO, IMPORTANT
			
			
		done
		if [ $win_type = 1 ]; then
#		## give more time to winetricks
#		while [[ $(pgrep 'winetricks') ]]; do
#			sleep 1
#		done
		kill $WAIT_UI_1
			w_width=$((800+$scale))
			$yad_bin --width=$w_width --title "$w_title" --window-icon=$img_wine_desk_ui --borders=15 \
			$main_height $main_scroll --notebook --key=$key --tab-pos=right --tab-border=2 \
			--text="$main_tab_text" "${t_display[@]}"
			e_exit=$?
			## yad tabed window is displayed here.
			if [ $t_var == _resume ]; then
				if [ $e_exit -ge 0 ]; then exit 0; fi
			else
				if [ $e_exit = 1 ]; then
					exit 0
				else
					if [ $t_var == _wfirst ]; then
						fn_wine_basic_feed
					else
						extract_tmp_settings
					fi
				fi
			fi
		fi

	}
	## from here, this meaning tab data are modified/set and validation button has been pressed.
	extract_tmp_settings(){
		echo -e "$i_notif\n@@@@ extract_tmp_settings @@@@\n$e_notif"
		wait_message='WORKING'
		fn_plz_wait &
		WAIT_UI_2=$(ps -A | grep "yad" | awk '{print $1}'| sed -n '1p')
		echo -e "$g_notif\n>>>> tab temp resume :\n${tab_temp[@]}$e_notif"
		for sets in "${tab_temp[@]}"; do
			unset _out_conf_sets
			_out_var=$(printf "$sets"| cut -d';' -f1)
			_out_var_val=$(printf "$sets"| cut -d';' -f2)
			_out_tmp_a=$(printf "$sets"| cut -d';' -f4)
			_out_tmp_b=$(printf "$sets"| cut -d';' -f5)
			fn_reconf=(reconf$_out_var)
			
			from_basic=$(cat $_out_tmp_a)
			## convert yad tab output datas to usable data for basic>output diff.
			
			## filter per conf type first. Output analysis is not necessary the same for all.
			if [ $_out_var == _tricks ]; then
				from_output=$(cat $_out_tmp_b| sed -n "s/;/\n/g;p"| cat -b | grep -v "FALSE" | awk 'NF'| \
				sed -E -n "s/^.*\ ([0-9]{1,3})\t(.*$)/\1#\2/;s/TRUE/1/g;p")
			else
				from_output=$(cat $_out_tmp_b| sed -n "s/;/\n/g;p"| cat -b | awk 'NF'| \
				sed -E -n "s/^.*\ ([0-9]{1,3})\t(.*$)/\1#\2/;s/TRUE/1/g;s/FALSE/0/g;p")
			fi
			regex='(.*);(.*);(.*);(.*);(.*)'
			ifs=$IFS
			IFS=$(echo -ne "\n\b")
			for _conf_var in ${from_output}; do
				_line=$(printf "$_conf_var"| cut -d'#' -f1)
				_val=$(printf "$_conf_var"| cut -d'#' -f2)
					_out_line=$(echo "$from_basic"| sed -n $_line\p| sed -E -n "s/$regex/\2/p" )
				if [[ $_out_line ]]; then
					## send all output datas in a single list that be used at the beginning of reconf part. 
					_out_conf_sets+=($_out_line=$_val)
				fi				
			done
			
			echo -e "$g_notif\n>>>> $_out_var vars list:\n${_out_conf_sets[@]}\n$e_notif"
			
			## define the config write method.
			## If config file exist choose between 2 method:
			if [ $from_config = 1 ]; then
			## section already exist:
				_fn_exist=$(cat $config_file| grep -wc "$_out_var")
				## start the reconf section.
				echo -e "$g_notif >>>>> reconf section for $_out_var$e_notif"
				${fn_reconf}
				## If section exist, enter changes then insert it in tempory conf file.
				if [ $_fn_exist -gt 0 ]; then
				## define the beginning and the end of section text.
					echo -e "$g_notif >>>>> write temp file for $_out_var $e_notif"
					_first=$(echo "$_section"| sed -n '1p'|sed -n "s|/|\\\/|g;p" )
					_last=$(echo "$_section"| sed -n '$p')
					## suppress previous section text from the conf file and replace it with section keyword
					## in temporary conf file.
					cat $TEMP_conf| sed -n "/$_first/,/^$_last/{;s/.*/$_out_var/};p"| uniq > $TEMP_edit
					## Then replace the keyword by the modified section text.
					perl -ni -pe "s|^$_out_var|$(echo "$_section")|i" $TEMP_edit
					mv -f $TEMP_edit $TEMP_conf
				else
				## section doesn't exist: Then, just add at the end of the temporary conf file.
					echo -e "$_section\n" >> $TEMP_conf
				fi
			else
			## For new fresh conf, just write by pushing section conf text at the end of the file
				echo -e "$g_notif >>>>> new fresh section for $_out_var$e_notif"
				${fn_reconf}
				echo -e "$_section\n" >> $TEMP_conf
			fi
			IFS=$ifs
		done
		## if conf file is new one, define the conf name before copying.
		if [ $from_config = 0 ]; then
			config_file=$(printf "$bottle_prefix"| sed -n "s/^\.//p")'.conf'
			cp -f -T $TEMP_conf $HOME/.winestarter/configs/$config_file
		else
			cp -f -T $TEMP_conf $config_file
		fi
		kill $WAIT_UI_2
		end_game_display
		if [ $? -ge 0 ]; then exit 0; fi
	}
	## wait patiently window
	fn_plz_wait(){
		$yad_bin --width=200 --title "Please wait..." --text-align=center --no-buttons $on_top \
		--window-icon=$img_wine_ui --progress --pulsate --auto-close \
		--text="$vb\\$wait_message$end" --progress-text=""
	}
	## end process window and tab
	end_game_display(){
		unset  tab_set tab_temp cfg_set t_display form_win 
		# launch default start window
		conf_target=$(printf "$bottle_prefix"|  sed -n "s/^.*[\/.\|.]\(\w*[Aa-Zz]\.\w*[Aa-Zz]*\)/\1/g;p")
		w_title="Wine Starter"
		main_tab_text="$bf Configuration applied to$end $brf$conf_target$end"
		tab_set=("1;_resume;Resume;fn_end_game_1;$img_wine_desk_ui")
#		"2;_resume;Warnings;fn_end_game_2;$img_wine_desk_ui")
		# window style and function
		win_type=1
		focus='--focus-field=2'
		# create main window variables
		default_tab_create
	}
	fn_end_game_1(){
		## --field="$vb New Wine prefix $end"#$img_wine_add
		## "Create and config a fresh new Wine prefix":FBTN "$main_cmd_0" \
		
		res_action="bash $bash_opt \"winestarter "$conf_target".conf\""
		res_launch="$vb Launch Winetarter$end"
		res_special="$vb Launch or relaunch boot features:$end"
		w_text="$vb\All change are saved to the bootle configuration.\\n\
You can launch the script now or later from the desktop file entry (if any) or from a terminal window with the command line:$end\\n\
$nf\winetstarter $conf_target.conf$end"
		w_res_0="Note and warnings : When using this tool, you can occur window crash or freeze. This is a Yad issue that will be hopefuly fix in a near futur."
		basic_sets="'';;;;LBL;;
$res_action;;;$res_launch;FBTN;;
'';;;;LBL;;
'';;;$w_res_0;LBL;;"
		item_sep='!'
		# start form display
		win_type=1
		default_win_design
		# create main window variables
	}
#	fn_end_game_2(){
#		w_text="Blabla"
#		w_res_1="Blobloblo"
#		basic_sets="'';;;$w_res_1;LBL;;
#'';;;;LBL;;"
#		# start form display
#		win_type=1
#		default_win_design
#		# create main window variables
#	}
	reconf_wine(){		
		# "user_prefix bottle_prefix game_path game_dir game_exe use_winepath wine_path wine_ver"
		echo -e "$g_notif\n##### reconf_wine $e_notif"
		## send output datas to local script env.
		local ${_out_conf_sets[@]}
		## rewrite specifics variables for correct display and use.
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			eval _listed='$'$_var
			if [[ $_listed =~ ^$HOME[\/]?$ ]]; then
				if [[ $_var != user_prefix ]]; then local $_var=''; fi
			fi
			case $_var in
				'bottle_prefix') bottle_prefix=$(printf "$bottle_prefix"| sed -n "s|^.*/||g;p") ;;
				'game_path')
					game_key=$(printf "$game_path"| sed -n "s|^.*/||g;p")
					if [[ $game_key =~ $USER ]]; then game_key=''; fi
					if [[ $game_path == $HOME ]]; then game_path=''; fi
				;;
				'game_dir')
					if [[ $game_key != '' ]]; then
						if [ $(printf "$game_dir"| grep -c "$game_key") -gt 0 ]; then
							game_dir=$(printf "$game_dir"| \
							sed -n "s|^.*\w*$game_key\(.*$\)|$game_key\1|p")
						fi
					else
						if [ $(printf "$game_dir"| grep -c "Program\ Files") -gt 0 ]; then
							game_dir=$(printf "$game_dir"| \
							sed -n "s|^.*Files$elf_ext/\(.*\)$|\1|p")
						else
							game_dir=$(printf "$game_dir"| sed -n "s|^.*drive_c/\(.*\)$|\1|g;p")
						fi
					fi
				;;
				'game_exe')
					if [[ $game_exe =~ ^.*\.(exe|EXE)$ ]]; then
						game_exe=$(printf "$game_exe"| \
						sed -En "s|^.*($game_dir)/(.*)([exe|EXE]?)$|\2\3|p")
					else
						game_exe=''
					fi
				;;
			esac
		done
		## Extended appears in tab only if extended option check pbox is setted.
		if [ $_extended = 1 ]; then
			if ! [ -e $user_prefix/$bottle_prefix/options.log ]; then
				touch $user_prefix/$bottle_prefix/options.log
			fi
			for opts in ${reconf_list[@]}; do
				_opt_var=$(printf "$opts"| cut -d';' -f3)
				_opt_id=$(printf "$opts"| cut -d';' -f2)
				eval _var='$'$_opt_var
				if [ $_var -gt 0 ]; then
					_args+=("-$_opt_id")
				fi
			done
			if [ $wine_arg_msc ]; then
				if [[ $wine_arg_msc != unset ]]; then
					## add editable option to args list.
					_args+=("$wine_arg_msc")
					##* At the point wine args options list is complete and ready to be wrote.
					##* Next process is for changes and write of bottle options.log.
					## Check if a diff appears between present options and bottle options.log:
					## Make of wine_arg_msc a usable list.
					msc_arg_list=("$wine_arg_msc")
					## Control last modification EPOC time.
					if [ -s $option_log ]; then
						_option_log_mod=$(stat -c %Y $option_log )
					else
						_option_log_mod=$(date +%s)
					fi
					## compare previous EPOC check and new EPOC check.
					if [ $_option_log_mod -gt $_option_log_pre ]; then
						## first, check if elements of wine_arg_msc are not in bottle options menu.
						for _mod_line in ${reconf_list[@]}; do
							_mod_id=$(printf "$_mod_line"| cut -d";" -f2)
								## if option in bottle options menu list is not in wine_arg_msc,
								## add it to wine_opts value for config file write.
								if [ $(echo "${msc_arg_list[*]}"| grep -c "$_mod_id") -eq 0 ]; then
									msc_arg_list+=("-$_mod_opt")
								fi
						done
					fi
					##* Now, we need to compare and evaluate if wine_arg_msc elements have to be add to 
					##* bottle options.log.
					for _msc_val in ${msc_arg_list[@]}; do
						## create the short tag for wine_arg_msc elements. If element has ponctuation like
						## '_' or '-', remove all words before till leaving one unique word. If not
						## ponctuation is detected, leave as it is.
						if [ $(echo -e "$_msc_val"| egrep -c "[[:punct:]]") -gt 0 ]; then
							_msc_short=$(echo -e "$_msc_val"| sed -nE "s/^.*[[:punct:]](\w*[a-z]$)/\1/p")
						else
							_msc_short="$_msc_val"
						fi
						## remove all options suffix element to create unique ID per element.
						_msc_arg=$(echo -e "$_msc_val"| sed -n "s/^-//p")
						_msc_var=("wine_arg_$_msc_short")
						## if short tag already exist, number it to make a different ID.
						if [[ $(cat $option_log| egrep -c "$_msc_var.*;") -gt 0 && \
						$(cat $option_log| egrep -c "$_msc_arg;$_msc_var.*;") -eq 0 ]]; then
							_msc_short=$_msc_short"_"$msc_n
							_msc_var=("wine_arg_$_msc_short")
							msc_n=$[ $msc_n+1 ]
						fi
						## Final step check if option is not present neither in bottle options.log and
						## bottle menu options list, then write it to bottle options.log with a value of
						## 0 (not in bottle options menu list yet)
						if [ $(cat $option_log| egrep -c "$_msc_arg") -eq 0 ]; then
							if [ $(echo "${reconf_list[@]}"| egrep -c "$_msc_arg") -eq 0 ]; then
								## last number in file insertion tell if option is add to default menu.
								printf "$_msc_short;$_msc_arg;$_msc_var;0\n" >> $option_log
							fi
						fi
					done
				else
				## if global options value return 0 or 'unset' 
					_args+=('')
				fi
			fi
			wine_opts="${_args[@]}"
		fi
		_wine=1
		if [ $from_config = 0 ]; then newconf_headers; fi
		newconf_wine
	}
	newconf_wine(){
			_section="## Allow extended features for winestarter configurator; off (0), on (1)
_extended=$_extended\n
## default is $HOME
user_prefix=$user_prefix
## game/appli prefix name
bottle_prefix=\"$bottle_prefix\"
## default system path of the game/appli if not in the chosen Wine prefix
game_path=\"$game_path\"
## Full game dir name in Program Files (including Program Files dir name)
game_dir=\"$game_dir\"
game_exe=\"$game_exe\"
## set if the app is portable or to be installed in C: drive root: no (0), yes (1).
app_portable=$app_portable
## if classic wine command fail, execute .exe inside the directory
special_cmd=$special_cmd
## wine can use \"start\" command to launch apps or installer from absolute path
## useful on old or recalcitrant buggy app.
start_cmd=0
## set a 64 bits bottle: false (0), true (1)
wine_elf=$wine_elf

## In some apps, it's possible to send extended options at the end of command line.
## It can be some extra DLLs, game map, etc. Add them here.
wine_opts=\"$wine_opts\"

## to lauch winecfg at first launch
w_config=1
## Do not remove or edit below except if you don't use winestarter configurator.
_wine=$_wine"
	}
	newconf_headers(){
		## insert script headers at first config step
		conf_headers="#! /bin/bash\n
##  Winestarter Configurator
##  Fri Feb  10 14:00:00 2017
##  Copyright  2017  PirateProd
##  <wildtruc@noneltd.net>
##  This program is free software; you can redistribute it and/or
##  modify it under the terms of the GNU Lesser General Public
##  License as published by the Free Software Foundation; either
##  version 2.1 of the License, or (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
##  Lesser General Public License for more details.
##
##  You should have received a copy of the GNU Lesser General Public
##  License along with main.c;if not, write to the Free Software
##  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301,  USA

## comments with '##' are user help comments
## comments with '#' are unset feature
"
		echo -e "$conf_headers" > $TEMP_conf
	}

	reconf_wbin(){
		echo -e "$g_notif\n##### reconf_wbin $e_notif"
		## send output datas to local script env.
		local ${_out_conf_sets[@]}
		## take care that wine_path is not HOME prefix. user_prefix/winebin dir is default, but could
		## different as user want. 
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			case $_var in
				'wine_path')
					_def_val=.winebin
					if [[ $_val != $HOME || $_val != $user_prefix/$_def_val ]]; then
						_def_val=$(printf "$_val"| sed -n "s/^.*\///p")
						_prefix=$(printf "$_val"| sed -E -n "s/^(.*)\/(.*)$/\1/p")
						wine_path=$_prefix/$_def_val
					else
						wine_path=$user_prefix/$_def_val
					fi
				;;
				'wine_ver')
					## if taken from download popup window, wine_ver is read in w_bin_tmp file, else from
					## main dir chooser.
					wine_bin_temp=/tmp/w_binary.*
#					if [ -s /tmp/w_bin_tmp ]; then
					if [ -s $wine_bin_temp ]; then
#						## remove all empty space from w_bin_tmp file.
#						_val=$(cat /tmp/w_bin_tmp)
						_val=$(cat $wine_bin_temp)
						## w_bin_tmp get two parts, cut to define the pack kind, PoL or WineHQ (wine_pack)
						## and version (wine_ver).
						wine_pack=$(printf $_val| cut -d';' -f2)
						wine_ver=$(printf $_val| cut -d';' -f1)
					else
#						if [[ $_val =~ \.winebin$ ]]; then
						if [[ $_val =~ $_def_val$ ]]; then
							wine_ver=''
						else
							wine_ver=$(printf "$_val"| sed -n "s|^.*/||g;p")
						fi
					fi
					rm -f $wine_bin_temp
				;;
			esac
		done
		if [ $use_winepath = 1 ]; then _wbin=1; fi
		newconf_wbin
	}
	newconf_wbin(){
		_section="## Use a specific Wine path: yes (1), no (0).
use_winepath=$use_winepath
## where is your custom Wine binary, if any
wine_path=\"$wine_path\"
## custom Wine binary name
wine_ver='$wine_ver'
## Which kind of packages do you want to use:
## PlayOnLinux (0), WineHQ staging (1), leave empty if already in bin directory.
wine_pack=$wine_pack
## Do not remove or edit below except if you don't use winestarter configurator.
_wbin=$_wbin"
	}
	reconf_install(){
		echo -e "$g_notif\n##### reconf_install $e_notif"
		M=0
		local ${_out_conf_sets[@]}
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			eval _listed='$'$_var
			if [[ $_listed =~ ^$HOME[\/]?$ ]]; then
				local $_var=''
			fi
			case $_var in
				'w_exe_path')
					if [[ $_listed =~ ^.*\.(exe|EXE|msi|MSI)$ ]]; then
						if ! [ -s $config_file ]; then
							w_install_exe=1
						fi
						((M++))
					fi
				;;
				'w_tricks_opts')
					if [ $_listed = 1 ]; then w_tricks_opts='--no-isolate'; else w_tricks_opts=''; fi
				;;
				'w_more_pkgs')
#					if [[ $_listed ]]; then
					if [ $(echo "$_listed"| grep -c "\,") -gt 0 ]; then
						w_more_pkgs=$(echo -e "$_listed"| sed -E -n "s/,/\n/g;p")
						((M++))
					fi
				;;
				'w_install_dir')
					if [[ $w_install_zip ]]; then
						if [[ $(printf "$_listed"| egrep -c "^.*-") -gt 0 ]]; then
							w_install_dir=$(printf "$_listed"| \
							sed -En "s/([[:alnum:]]*)-.*$/\1/;s/^.*\///g;p")
						fi
						((M++))
					else
						w_install_dir=''
					fi
				;;
				'w_download_dir')
					w_download_dir=$XDG_DOWNLOAD_DIR
				;;
			esac
			if [ $M -gt 0 ]; then
				if [ -s $user_prefix/$bottle_prefix/packages.log ];then
					check=$(printf "$_listed"| sed -n "s/^.*\///g;p")
					if [ $(cat $user_prefix/$bottle_prefix/packages.log| grep -wc "$check" ) -gt 0 ]; then
						w_install_exe=0
					else
						w_install_exe=1
					fi
				else
					w_install_exe=1
				fi
			fi
		done
#		if [ $M -gt 0 ]; then _install=1; fi
#		_install=1
		if [ $w_install_exe = 1 ]; then _install=1; else _install=0; fi
		newconf_install
	}
	newconf_install(){
		if [[ $w_extra_script == $HOME/ ]]; then w_extra_script=''; fi
		_section="## This option allow to install .exe or .msi through winestarter process.
## It's possible to replace file name path by an internet URL for download it.
w_install_exe=$w_install_exe
## Winetricks options, if any
w_tricks_opts='$w_tricks_opts'
## Full path of the software exe/msi file to install
w_exe_path=\"$w_exe_path\"
## Additional associated dlls or app packages list to install (if any)
w_more_pkgs='$w_more_pkgs'
## In some cases, install is provided by extractible or auto-extractible package
## This option will install them in the provided directory to the Program Files path
w_install_zip=\"$w_install_zip\"
## otherwise, you can specify the install dir from the root C: drive.
w_install_dir=\"$w_install_dir\"
## Download dir is the user default one, you can change it here.
w_download_dir=\"$w_download_dir\"
## user script: You can add here a personal or a community script (updater, logs, etc)
## It will be automaticaly pasted in the installed app directory.
## This is very optional and at your own risk
w_extra_script=\"$w_extra_script\"
## Do not remove or edit below except if you don't use winestarter configurator.
_install=$_install"
	}
	reconf_tricks(){
		echo -e "$g_notif\n##### reconf_tricks $e_notif"
		M=0
		local ${_out_conf_sets[@]}
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			eval _listed='$'$_var
			if [[ $_var =~ (ie8|ie7|ie6) ]]; then _var="$_var wininet winhttp"; fi
			if [[ $_listed = 1 ]]; then
				_tricks_var+=("$_var")
			fi
		done
		w_tricks_list_prev=$w_tricks_list
		if [[ $w_tricks_list_prev == '' ]]; then
			if [ ${#_tricks_var[*]} -gt 0 ]; then
				w_install_tricks=1
			else
				w_install_tricks=0
			fi
		fi
		w_tricks_list=$(echo -e "${_tricks_var[@]}"|tr ' ' ',')
		if [[ $w_tricks_list_prev ]]; then
			for _prev in ${_tricks_var[@]}; do
				if [ $(printf "$w_tricks_list_prev"| grep -c "$_prev") -eq 0 ]; then
					_tricks_var_new+=("$_prev")
				fi
			done
			_tricks_list_new=$(echo -e "${_tricks_var_new[@]}"|tr ' ' ',')
#			w_tricks_list=$(printf "$w_tricks_list_prev"| sed -E -n "s/^(.*)/\1,$_tricks_list_new/p")
			if [ ${#_tricks_var_new[*]} -gt 0 ]; then
				w_tricks_list=$(printf "$w_tricks_list_prev"| sed -E -n "s/^(.*)/\1,$_tricks_list_new/p")
				w_install_tricks=1
			else
				w_tricks_list=$w_tricks_list_prev
				w_install_tricks=0
			fi
		fi
		
		if [ $(printf "$w_tricks_list"| grep -c .) -gt 0 ]; then _tricks=1; else _tricks=0; fi
		newconf_tricks
	}
	newconf_tricks(){
		_section="## (0) first install launch and prefix creation already set, (1) first launch
w_install_tricks=$w_install_tricks
## Winetricks components list
w_tricks_list=\"$w_tricks_list\"
## Do not remove or edit below except if you don't use winestarter configurator.
_tricks=$_tricks"
	}
	reconf_reged(){
		echo -e "$g_notif\n##### reconf_reged $e_notif"
		M=0
		R=0
		unset _reged_var
		## extract first here the editable regedit field into a readable list
		user_edit=$(echo "$from_output"| grep "HKEY_CURRENT_USER"| cut -d'#' -f2)
	
		local ${_out_conf_sets[@]}
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			echo -e "$g_notif >>>>> ${_reged_var[*]} $e_notif"
			if ! [[ $_var =~ ^dll*|^mime* ]]; then
				if [[ $_var == user_reg ]]; then
					if [[ $user_reg =~ ^\[.*\]$ ]]; then unset -v user_reg; _val='unset'; fi
				fi
				if [[ $_val != unset ]]; then
					if [[ $_var == csmt ]]; then
						if [[ $_val == enabled ]]; then _val='00000001'; else _val='00000000'; fi
					fi
					if [[ $_val =~ [0-9]{8} ]]; then
						_reged_var+=("\"$_var\"=dword:$_val")
					else
						_reged_var+=("\"$_var\"=\"$_val\"")
					fi
#				else
#					_reged_unset+=($_var)
				fi
			else
				if [ $_extended = 1 ]; then
					if [ $_val != unset ]; then
						case $_var in
							'Selected_Files')
								echo -e "$g_notif >>>>> $_var $e_notif"
								selected_files_list=( $(echo "$_val"| sed -n "s/,/\n/g;p") )
								for Files in ${selected_files_list[@]}; do
									if [ $(printf "$local_association"| grep -c .) -gt 0  ]; then
										prev_asso="$local_association,"
										file_ext=$(printf "$Files"| sed -n "s/^.*\.//g;p")
										if [ $(printf "$local_association"| grep -c "$file_ext") -eq 0 ]; then
											mime_type=$(xdg-mime query filetype $Files)
											if [ $(printf "		$mime_type"| grep -c .) -gt 0 ]; then
												## define the the reg mime type elements
												_filetype=$(printf "$Files"|sed -n "s/^.*\.//g;p")
												_doctype=$(printf "$_filetype"|sed -n "s/.*/\U&/p")'file'
												## add them to the resource list
												res_mime=$HOME/.winestarter/resources/mime-type.lst
												if [ $(cat $res_mime |grep -c "_doctype") -eq 0 ]; then
													printf "$_filetype:$_doctype:$mime_type\n" >> $res_mime
												fi
												## add the file extension to the config file type section
													FileType_list+=( "$_filetype" )
											fi
										fi
									else
										FileType_list+=( $(printf "$Files"|sed -n "s/^.*\.//g;p") )
									fi
								done
								_val=$prev_asso$(printf "${FileType_list[*]}"| tr ' ' ',')
							;;
							'mime_preset')
								echo -e "$g_notif >>>>> $_var $e_notif"
								mime_preset_list=( "$_val" )
								if [ $(printf "$local_association"| grep -c .) -gt 0  ]; then
									for preset in ${mime_preset_list[@]}; do
										if [ $(printf "$local_association"| grep -c "$preset") -eq 0 ]; then
											mime_preset_add+=("$preset")
										fi
									done
									if [ ${#mime_preset_add[@]} -gt 0 ]; then _sep=','; ((M++)); fi
									prev_asso="$local_association$_sep"
									_val=$prev_asso$(printf "${mime_preset_add[*]}"| tr ' ' ',')
									_val=$prev_asso${mime_preset_add[*]}
								else
									_val=$(echo "$mime_preset"| tr ' ' ','); ((M++))
								fi
								local local_association=$_val
							;;
							'dll_reg_type')
								echo -e "$g_notif >>>>> $_var $e_notif"
								if [[ $_val == register ]]; then _reg_class=1; else _reg_class=0; fi; ((R++))
							;;
							'dll_elf_type')
								echo -e "$g_notif >>>>> $_var $e_notif"
								if [[ $_val == both ]]; then
									_reg_elf=2
								else
									if [[ $_val == wine32 ]];then _reg_elf=0; else _reg_elf=1; fi
								fi
							;;
							'dll_file_list')
								echo -e "$g_notif >>>>> $_var $e_notif"
								if [[ $_val =~ \.(dll|DLL)$ ]]; then
									_dlls_list=$(printf "$_val"| tr ',' '\n')
									for _dlls in ${_dlls_list[@]}; do
										_conf_dlls+=( "$(printf "$_dlls"| sed -n "s/^.*\///g;p")," )
									done
									echo -e "$g_notif >>>>> ${_conf_dlls[@]} $e_notif"
									_reg_dlls=$(echo "${_conf_dlls[@]}"| sed -n "s/\ //g;s/\,$//p")
								fi
							;;
						esac
						if [ $R -gt 0 ]; then
							dll_reg_manager="$_reg_class,$_reg_elf,$_reg_dlls"; ((M++))
						else
							dll_reg_manager=''
						fi
					else
						local $_var=''
					fi
				fi
			fi
		done
		if [[ $(printf "$user_edit"| grep -c .) -gt 0 || \
		$(printf "$user_edit"| grep -c "option_set") -gt 0 ]]; then
			for _new_reg in $(echo -e "$user_edit"); do
				## form: "DirectDrawRenderer"="gdi"
				## for regex form: (")(DirectDrawRenderer)(")=(")(gdi)(?>:0..1)(")
				regex='([\"]?)(\w*)([\"]?)=([\"]?)(\w*)([:[0-9]*]?)([\"]?)$'
				_var=$(echo "$_new_reg"| sed -E -n "s/$regex/\2/p")
				_val=$(echo "$_new_reg"| sed -E -n "s/$regex/\5\6/p")
				## check first if editable values are not previously unset before adding anything to reg.
				eval _pre_var='$'$_var
				if [[ $_pre_var != unset ]]; then
					if [ $(echo "${_reged_var[*]}"| grep -c "$_var" ) -eq 0 ]; then
						if [[ $_val =~ dword: ]]; then
							_reged_var+=("\"$_var\"=$_val")
						else
							_reged_var+=("\"$_var\"=\"$_val\"")
						fi
					fi
				fi
			done
		fi
		if [ ${#_reged_var[*]} -gt 0 ]; then
#			reg_final=$(echo -e "[HKEY_CURRENT_USER\\\\Software\\\\Wine\\\\Direct3D]\n${_reged_var[*]}")
			reg_final=$(echo -e "[HKEY_CURRENT_USER\\\\\\\Software\\\\\\\Wine\\\\\\\Direct3D]\n${_reged_var[*]}")
			((M++))
		else
			reg_final=''
		fi
		if [ $M -gt 0 ]; then _reged=1; fi
#		_reged=1
		newconf_reged
	}
	newconf_reged(){
		_section="## extra wine registry specific entry
## leave user_reg blank if none : user_reg=''
## possible values are:
## \"StrictDrawOrdering\"=\"enabled\/disabled\"
## \"DirectDrawRenderer\"=\"opengl\"
## \"Nonpower2Mode\"=\"repack\"
## \"OffscreenRenderingMode\"=\"fbo\"
## \"RenderTargetLockMode\"=\"auto\"
## \"UseGLSL\"=\"readtex\"
## \"VideoMemorySize\"=\"(memory size of your graphic card)\"
user_reg='$reg_final'
## Allow local system apps to launch some mime-file type:
local_association=\"$local_association\"
## Register/unsregister DLLs libraies (one arch at a time):
## example: 1,0,foo.dll,poo.dll,
## Where first 1 is register and 0 unregister and secondary 0/1 is wine32/wine64, 2 is both
dll_reg_manager=\"$dll_reg_manager\"
## Do not remove or edit below except if you don't use winestarter configurator.
_reged=$_reged"
	}
	reconf_nvidia_1(){
		echo -e "$g_notif\n##### reconf_nvidia_1 $e_notif"
		M=0
		local ${_out_conf_sets[@]}
		
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			if [[ $_val != unset ]]; then
				case $_var in
				'__GL_FSAA_MODE')
					## fsaa mode comes with special text options to be convert in numerics for control type,
					## and multiplier has to be converted from 1,2,3,4,5 conf value to driver's one.
					if [ $__GL_FSAA_MODE -gt 0 ]; then
						case $__GL_FSAAA_CTRL in
							'full control') __GL_FSAAAppControlled=0; __GL_FSAAAppEnhanced=0 ;;
							'enhanced') __GL_FSAAAppControlled=0; __GL_FSAAAppEnhanced=1 ;;
							'ignored') __GL_FSAAAppControlled=1; __GL_FSAAAppEnhanced=1 ;;
						esac
						local cmt__GL_FSAAAppControlled='export'
						local cmt__GL_FSAAAppEnhanced='export'
						case $__GL_FSAA_MODE in
							'2') __GL_FSAA_MODE=5;;
							'3') __GL_FSAA_MODE=9;;
							'4') __GL_FSAA_MODE=10;;
							'5') __GL_FSAA_MODE=11;;
						esac
						local cmt$_var='export'; ((M++))
					else
						local cmt__GL_FSAA_MODE='#export'
						local cmt__GL_FSAAAppControlled='#export'
						local cmt__GL_FSAAAppEnhanced='#export'
					fi
#				fi
				;;
				'__GL_LOG_MAX_ANISO')
					if [ $_val = 0 ]; then
						local cmt$_var='#export'
					else
						local cmt$_var='export'; ((M++))
					fi
				;;
#				`printf "$_var"| egrep '^__GL_[AL|TH|SY|Op].*$'` ) local cmt$_var='export' ;;
				*) local cmt$_var='export'; ((M++)) ;;
				esac
			else
				local $_var=0
				local cmt$_var='#export'
			fi
		done
		if [ $M -gt 0 ]; then _nvidia_1=1; fi
		newconf_nvidia_1

	}
	newconf_nvidia_1(){
		_section="### NVIDIA ENV VARIABLE OPTIONS
## FSAA: Full Scene Anti Aliasing: can be set from 1 to 5:
## off [0], 2x (2xMS) [1], 4x (4xMS) [5], 8x (4xSS, 2xMS) [9], 8x (8xMS) [10], 16x (4xSS, 4xMS) [11]
$cmt__GL_FSAA_MODE __GL_FSAA_MODE=$__GL_FSAA_MODE
## if set, FSAA comes 2 others variables that have to be set as follow respectively :
## To get FSAA full control: [0] [0]
## To get FSAA enhanced for application using multisample : [0] [1]
## To get FSAA controlled by nvidia-setting ignored : [1] [1]
$cmt__GL_FSAAAppControlled __GL_FSAAAppControlled=$__GL_FSAAAppControlled
$cmt__GL_FSAAAppEnhanced __GL_FSAAAppEnhanced=$__GL_FSAAAppEnhanced
## FXAA, Fast approximate antialiasing: take avantage over traditional multisampling and
## supersampling methods: (0) (1)
$cmt__GL_ALLOW_FXAA_USAGE __GL_ALLOW_FXAA_USAGE=$__GL_ALLOW_FXAA_USAGE
## anisotropic texture filtering set : off (0), x2 (1), x4 (2), x8 (3), x16 (4)
$cmt__GL_LOG_MAX_ANISO __GL_LOG_MAX_ANISO=$__GL_LOG_MAX_ANISO
## synchronize vertical refresh (0), (1)
$cmt__GL_SYNC_TO_VBLANK __GL_SYNC_TO_VBLANK=$__GL_SYNC_TO_VBLANK
## if libpthread is not enabled by default (ex: wine),
## it can be force to be set with LD_PRELOAD env variable.
$cmt__GL_THREADED_OPTIMIZATIONS LD_PRELOAD=\"libpthread.so.0 libGL.so.1\" __GL_THREADED_OPTIMIZATIONS=$__GL_THREADED_OPTIMIZATIONS
## Perfomance from Nvidia Settings tool can be set to gain graphic performance instead of quality
## Quality (1), Mixed (2), Perfomance (3), otherwise comment it to unset.
$cmt__GL_OpenGLImageSettings __GL_OpenGLImageSettings=$__GL_OpenGLImageSettings
## Do not remove or edit below except if you don't use winestarter configurator.
_nvidia_1=$_nvidia_1"
	}
	reconf_nvidia_2(){
		echo -e "$g_notif\n##### reconf_nvidia_2 $e_notif"
		local ${_out_conf_sets[@]}
		M=0
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			if [[ $_val != unset ]]; then
				local cmt$_var='export'
				((M++))
			else
				if [[ $_var == __GL_YIELD ]]; then _val=''; else _val=0; fi
				local $_var=$_val
				local cmt$_var='#export'
			fi
		done
		if [ $M -gt 0 ]; then _nvidia_2=1; fi
		newconf_nvidia_2
	}
	newconf_nvidia_2(){
		_section="### NVIDIA MISCELLENOUS OPTIONS
## VBLANK can't bet set for multi screen, set here one of them only (if needed):
$cmt__GL_SYNC_DISPLAY_DEVICE __GL_SYNC_DISPLAY_DEVICE=\"$__GL_SYNC_DISPLAY_DEVICE\"
## to set or unset X server FBConfig behaviour : unset [0], set [1]
$cmt__GL_SORT_FBCONFIGS __GL_SORT_FBCONFIGS=$__GL_SORT_FBCONFIGS
## updating window moves yield, can be useful when some window app have refresh issues,
## value are : normal yield (''), no yield [\"NOTHING\"], background [\"USLEEP\"]
$cmt__GL_YIELD __GL_YIELD=\"$__GL_YIELD\"
## allow unofficial GLX implmentation. Mostly for debug mode or test, but can be useful
## in some case like Wine : off [0], on [1]
$cmt__GL_ALLOW_UNOFFICIAL_PROTOCOL __GL_ALLOW_UNOFFICIAL_PROTOCOL=$__GL_ALLOW_UNOFFICIAL_PROTOCOL
## if monitor can manage G-SYNC behaviour, this could improve display performance: off [0], on [1].
## Disable __GL_SYNC_TO_VBLANK to get faster performance and also xorg conf options \"stereo\", \"overlays\"
$cmt__GL_GSYNC_ALLOWED __GL_GSYNC_ALLOWED=$__GL_GSYNC_ALLOWED
## ignore GLGS extension check. Could be useful in case of some missing extension in appli GL sets.
## This will permit the shaders to be successfuly recompile: to off [0], on [1]
$cmt__GL_IGNORE_GLSL_EXT_REQS __GL_IGNORE_GLSL_EXT_REQS=$__GL_IGNORE_GLSL_EXT_REQS
## Do not remove or edit below except if you don't use winestarter configurator.
_nvidia_2=$_nvidia_2"
	}
	reconf_xrandr(){
		echo -e "$g_notif\n##### reconf_xrandr $e_notif"
		local ${_out_conf_sets[@]}
		M=0
		# bck_mode=1920x1080 set_mode=1280x720 'default_desktop=compiz ccp' secondary_desktop=marco 'mouse_dev=Logitech K230' 'set_buttons=3 2 1'
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			if [ $_val != unset ]; then
				case $_var in
					'bck_mode') set_xrandr="xrandr --output $monitor --mode $_val --rate 60"; auto_set=1 ;;
					'set_mode') bck_xrandr="xrandr --output $monitor --mode $_val --rate 60";;
					'default_desktop'|'secondary_desktop')
						if [[ $_val == mate ]]; then local $_var='marco'; fi
						if [[ $_val == compiz ]]; then local $_var='compiz ccp'; fi
						set_desktop_env=1
					;;
					'mouse_dev')
						mice=$(printf "${xinput_list[@]}"| grep "$mouse_dev")
						mice_nm=$(printf "$mice"| cut -d';' -f1)
						mice_id=$(printf "$mice"| cut -d';' -f2|sed -n "s/^.*=//p")
						if [[ $(printf "$mice_nm"| grep -c "$_val") -gt 0 ]]; then
							set_dev_id=$mice_id
						fi
						if [ $set_buttons == unset ]; then set_buttons='1 2 3'; fi
						mouse_btn="xinput set-button-map $set_dev_id $set_buttons"
						mouse_set=1
					;;
				esac
				((M++))
			else
				case $_var in
					'bck_mode') local $_var=''; auto_set=0 ;;
					'default_desktop'|'secondary_desktop') local $_var=''; set_desktop_env=0 ;;
					mouse_dev) local $_var='' ; mouse_set=0 ;;
					*) local $_var='';;
				esac
			fi
		done
		if [ $M -gt 0 ]; then _xrandr=1; else _xrandr=0; fi
		newconf_xrandr
	}
	newconf_xrandr(){
		_section="## optional xrandr command set, useful when you have strange fullscreen beshavior
## set enable (1) or disable (0)
auto_set=$auto_set
## fullscreen mode for your app ex: xrandr --output HDMI-1 --mode 1280x720 --rate 60
set_xrandr='$set_xrandr'
## your default screen mode
bck_xrandr='$bck_xrandr'

## optional desktop environment replacement:
## This option allow you to replace a buggy enduser graphical environment
## by a lighter one (OpenGl glitch, etc). This suppose a second desktop UI is already installed.
## set enable (1) or disable (0)
set_desktop_env=$set_desktop_env
## selec the default UI and replacement UI
default_desktop='$default_desktop'
secondary_desktop='$secondary_desktop'
## reverse mouse button
mouse_set=$mouse_set
mouse_dev='$mouse_dev'
mouse_btn='$mouse_btn'
## Do not remove or edit below except if you don't use winestarter configurator.
_xrandr=$_xrandr"
	}
	reconf_optimus(){
		echo -e "$g_notif\n##### reconf_optimus $e_notif"
		local ${_out_conf_sets[@]}
		M=0
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			if [ $_val != unset ]; then
				case $_var in
					'opti_starter') use_optimus=1 ;;
					'opti_accel')
						if [[ $opti_starter == primusrun ]]; then
							opti_accel=''
							opti_SYNC=''
						fi
					;;
				esac
				((M++))
			else
				case $_var in
					'opti_starter') use_optimus=0 ;;
				esac
				local $_var=''
			fi
		done
		if [ $use_optimus = 0 ]; then
			opti_sets=('opti_accel' 'opti_SYNC' 'opti_VBLK')
			for _set in ${opti_sets[@]}; do local $_set=''; done
			_optimus=0
		else
			if [ $M -gt 0 ]; then _optimus=1; else _optimus=0; fi
		fi
		newconf_optimus
	}
	newconf_optimus(){
		_section="## Optimus starter with options
## comment if you don't need them.
## Set if you want to use Optimus laptop display:
use_optimus=$use_optimus
## Set the optimus starter : 'optirun', 'primusrun'.
opti_starter=\"$opti_starter\"
## Set optirun vitualizer: 'virtualgl', 'primus'.
## If using 'primusrun' or 'Bumblebee default' leave 'opti_accel' blank ('')
opti_accel=\"$opti_accel\"
## Optimus images sync behaviour env option.
opti_SYNC=$opti_SYNC
## Optimus Vertical sync behavior, prefered is usualy off (0)
## Set enable (1) or disable (0)
opti_VBLK=$opti_VBLK
## Do not remove or edit below except if you don't use winestarter configurator.
_optimus=$_optimus"
	}
################################
## Yad UI messages and main text	
	messages(){
		main_tab_text="$bf Select settings by theme$end$nf\\n \
 Items or section leave \'unset\' or empty will not be set to the Winestarter config file$end"
		msg_wine="Set a new Wine prefix (mandatory)"
		msg_wcfg="Set a custom Wine binary"
		msg_tricks="Winetricks packages install (Windows packages)"
		msg_install="Install a Windows Software"
		msg_reged="Configure associated Wine registry sets (useful)"
		msg_nvidia1="Set Nvidia common OpenGL options (optional)"
		msg_nvidia2="Set Nvidia miscellenous options (extra)"
		msg_xrandr="Set XRandr game display geometry (optional)"
		msg_optimus="Set optimus specific options (optional)"
		msg_wine_opts="Set Wine specific options (optional)"
		msg_extended="Set extended features (very optional)"
		_warn_text="## Do not remove or edit below except if you don't use winestarter configurator."
	}
## Main Yad function
	fn_create_prefix(){
		## launch winetricks list building separatly before all ops,
		## otherwise it takes too much time when tabs are in building process.
		fn_tricks_list_build &
		unset form_win def_win default_win
		unset tab_set tab_temp cfg_set t_display nv_field
		main_tab_text="$bf Select settings by theme$end \\n \
 $nf\\Items or section leave \'unset\' or empty will not be set to the Winestarter config file$end \\n \
 $nf\\Last dowloadable:$end$vb PlayOnLinux > wine32 $pol32, wine64 $pol64$end, WineHQ > wine32 $hq32, wien64 $hq64, $nf\\System >$end $vb$sys_version$end"
		w_text="$bf Wine prefix$end\\n \
$vb Set wine prefix name, appli/game directories, etc.$end\\n \
$nf Check here the sections you would like to configure.$end"
		w_title="Wine Start Config"
		w_title1="$vb Nvidia OpenGL options$end"
		w_title2="$vb Miscellenous options$end"
		w_title3="$vb Advanced features$end"
		w_sub_3="Checking this option will allow extended features for advanced users"
		wine_tip0="$vb Main prefix install sections$end"

		## if Nvidia device is present, add it to menu entries.
		if [ $($lpci_bin| grep -c "NVIDIA") -gt 0 ]; then
			nv_field="'';;;;LBL;;
'';;;$w_title1;LBL;;
$_nvidia_1;_nvidia_1;Nvidia*(common);$msg_nvidia1;CHK;fn_nvidia_config_1;$img_nv_cm
$_nvidia_2;_nvidia_2;Nvidia*(extra)*;$msg_nvidia2;CHK;fn_nvidia_config_2;$img_nv_ext"
		fi
		## set IFS to include white space.
		ifs=$IFS
		IFS=$(echo -ne "\n\b")
		basic_sets="'';;;;LBL;;
'';;;$wine_tip0;LBL;;
$_wine;_wine;Wine*basics**;$msg_wine;CHK;fn_wine_config;$img_wine_cfg1
$_wbin;_wbin;Extra*binary**;$msg_wcfg;CHK;fn_wine_binary;$img_wine_cfg2
$_install;_install;Install*Software;$msg_install;CHK;fn_install_soft;$img_install
$_tricks;_tricks;Install*tricks**;$msg_tricks;CHK;fn_winetricks;$img_tricks
$_reged;_reged;Registry*options*;$msg_reged;CHK;fn_regedit_config;$img_reged
${nv_field[@]}
'';;;;LBL;;
'';;;$w_title2;LBL;;
$_xrandr;_xrandr;Display*options**;$msg_xrandr;CHK;fn_xrandr_config;$img_xrandr
$_optimus;_optimus;Optimus*options**;$msg_optimus;CHK;fn_optimus_config;$img_opti
'';;;;LBL;;
'';;;$w_title3;LBL;;
'';;;$w_sub_3;LBL;;
$_extended;_extended;;$msg_extended;CHK;;"
		## restore temporarly IFS.
		IFS=$ifs
		## item separator in output list
		item_sep=","
		## window style and function.
		win_type=0
		w_width='420'
		main_height='--height=420'
		main_scroll='--vscroll-policy=auto'
		extend_height='--height=400'
		extend_pol='--scroll'
		default_win_design
		# create main window variables.
		default_tab_design
		# export main function variables.
		default_tab_create
		
		
	}
	fn_nvidia_config(){
		# launch default start window
		w_title="Wine Starter"
		main_tab_text="$bf Reconfigure Nvidia's settings$end$nf\\n \
 Items leave \'unset\' will not be set to the Winestarter config file$end"

		tab_set=("1;_nvidia_1;Nvidia*(common);fn_nvidia_config_1;$img_nv_cm
2;_nvidia_2;Nvidia*(optional);fn_nvidia_config_2;$img_nv_ext")
		item_sep=","
		# window style and function
		win_type=1
		w_width='420'
		main_height='--height=420'
		main_scroll='--vscroll-policy=auto'
		extend_height='--height=400'
		extend_pol='--scroll'
		# create main window variables
		default_tab_create
	}
	fn_binary_env(){
		if ! [ -s $HOME/.winestarter/default-wine ]; then
			fn_binary_config
		fi
#		else
			wine_path=$(cat $HOME/.winestarter/default-wine| cut -d';' -f2)
			wine_elf=$(cat $HOME/.winestarter/default-wine| cut -d';' -f3)
			if [ $wine_elf = 1 ]; then	dir_elf='amd64'; else dir_elf='x86'; fi
			wine_ver=$wine_path/$dir_elf/$(cat $HOME/.winestarter/default-wine| cut -d';' -f1)
#		fi
		## set wine environment variables
		wine_elf_path=$wine_ver
		export WINEVERPATH=$wine_elf_path
		export PATH=$wine_elf_path/bin:$PATH
		export WINESERVER=$wine_elf_path/bin/wineserver
		export WINELOADER=$wine_elf_path/bin/wine
		if [ $wine_elf = 1 ]; then
			export WINEDLLPATH=$wine_elf_path/lib64/wine/fakedlls
			export LD_LIBRARY_PATH=$wine_elf_path/lib:$wine_elf_path/lib64:$LD_LIBRARY_PATH
		else
			export WINEDLLPATH=$wine_elf_path/lib/wine
			export LD_LIBRARY_PATH="$wine_elf_path/lib:$LD_LIBRARY_PATH"
		fi
		wine_bin=$WINELOADER
		sys_version=$($wine_bin --version)
		use_winepath=1
		wine_pack=1
		_wbin=1
		wine_bin_path=$wine_elf_path/bin/
		${wine_bin_path}wineboot -i
		
		## then, start as usual 
		if [ $b_set = 1 ]; then
			fn_basics_config
		else
			fn_create_prefix			
		fi
	}
	fn_binary_config(){
		# launch default start window
		w_title="Download and install Wine"
		w_text="$rb\\WARNING$end$vb : Wine executables and librairies are missing\\n\
To use Winestarter or Winetricks you must install them with your\\n\
packages manager or directly from WineHQ staging below.$end"
		w_wine_conf_path0="$vb\\Set full path where the Wine package will be installed:$end"
		w_wine_conf_path1="$vn(default is set to: $HOME/.winebin)$end"
		w_wine_conf_path01="$rb\\Pay attention$end$vb : Previous wine binaries path detected. Select one from the list below or download a new one.$end"
		w_wine_conf_path02=""
		w_wine_conf_path03=""
		w_wine_conf_txt="$nf\\Set full path$end"
		w_wine_conf_txt1="$nf\\Select package from default Wine path$end"
		w_wine_conf_txt2=""
		w_wine_conf_txt3=""
		w_wine_binary_tip="$vb\\You can choose any version from the selector, bust last is prefered.$end"
		set_as_default_tip="$vb\\When set to default, installed package will be available to all future bottles, until you choose a different one for a specific usage.$end"
		set_as_default=" Set package as default"
		set_64_tip="$vb\\You can set the whole environment to 64bits bottles, but it's not recommanded for a flexible usage.$end"
		set_64=" Set 64bits environment only"
	
		# x_width=$(xwininfo -stats -name "$w_title"| sed -E -n "s/^ +Width: +([0-9]+)/\1/p")
		width=520
		borders='15'
		win_image=$img_wine_ui
		c_chain=30
		out=$(printf "%0.s " $( seq 1 $c_chain))
		default_bin_dir=$HOME/.winebin
		wine_dis_cmd="bash $bash_opt \"select_wine_dis\""
		
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		n=0
		_basics_fields="$w_wine_binary_tip;LBL;''
$vb click and select a WineHQ package$end,$img_winedis_bt;FBTN;$wine_dis_cmd
$set_as_default_tip;LBL;''
$set_as_default;CHK;FALSE"
		_basics_64="$set_64_tip;LBL;''
$set_64;CHK;FALSE"
		## define system elf type and download destination
		if [[ $(uname -m) =~ ^.*64 ]]; then
			export wine_elf=1
			http_elf='x86_64'; dir_elf='amd64'; b_elf='64'
#			_basics_fields=$(echo -e "$_basics_fields\n$_basics_64")
			_basics_fields="$_basics_fields
$_basics_64"
		else
			export wine_elf=0
			http_elf='i686'; dir_elf='x86'; b_elf=''
		fi
		if [ -d $HOME/.winebin ]; then
			if [ $(ls -1 $HOME/.winebin| grep -c .) -gt 0 ]; then
				export wine_path=$HOME/.winebin
				if [[ $(uname -m) =~ ^.*64 ]]; then dir_elf='amd64'; else dir_elf='x86'; fi
				existing_list=$(ls -1 $HOME/.winebin/$dir_elf/| tr '\n' ','| sed -n "s/,$//g;p")
				_more_basics=";LBL;''
$w_wine_conf_path01;LBL;''
$w_wine_conf_path1;LBL;''
$w_wine_conf_txt$nf$out$end;CDIR;$default_bin_dir
$w_wine_conf_txt1;CB;$existing_list"
			_basics_fields="$_more_basics
$_basics_fields"
			fi
			n=1
		else
			_more_basics=";LBL;''
$w_wine_conf_path0;LBL;''
$w_wine_conf_path1;LBL;''
$w_wine_conf_txt$nf$out$end;CDIR;$default_bin_dir"
			_basics_fields="$_more_basics
$_basics_fields"
		fi
		_field_regex='^(.*);(.*);(.*)$'
		_fields=( $(echo -e "$_basics_fields"| sed -En "s/$_field_regex/--field=\1:\2/p") )
		_fields_sets=( $(echo -e "$_basics_fields"| sed -En "s/$_field_regex/\3/p") )
		wine_bin_output=$( $yad_bin --width=$width --title "$w_title" --separator=';'  \
		--item-separator=',' --window-icon=$img_wine_desk_ui --align=left --borders=$borders \
		--form --text="$w_text" --image=$win_image \
		"${_fields[@]}" "${_fields_sets[@]}")
		if [ $? = 1 ]; then exit 0; fi
		IFS=$ifs
		
		## set data coming fron the yad ui. 
		use_winepath=1
		wine_path=$(printf "$wine_bin_output"| cut -d';' -f4)
		wine_default=$(printf "$wine_bin_output"| cut -d';' -f$((8+$n)))
		wine_64=$(printf "$wine_bin_output"| cut -d';' -f$((10+$n)))
		
		wine_bin_temp=/tmp/w_binary.*
#		if [ -s /tmp/w_bin_tmp ]; then
		if [ -s $wine_bin_temp ]; then
#			wine_ver=$(cat /tmp/w_bin_tmp|cut -d';' -f1)
#			dist_dl_ver=$(cat /tmp/w_bin_tmp|cut -d';' -f3)
			wine_ver=$(cat $wine_bin_temp|cut -d';' -f1)
			dist_dl_ver=$(cat $wine_bin_temp|cut -d';' -f3)
			unset dl_list
			## create tmp dir for package download
			dl_dir=$(mktemp --tmpdir -d wine_dl.XXXXXXXX)	
			pkg_ver=$(printf $wine_ver| cut -d'-' -f1)
			pkg_rel=$(printf $wine_ver| cut -d'-' -f2)

			## control if wine bin dir exist. If not create it from default
			if ! [ -d $wine_path/$dir_elf/ ]; then mkdir -p $wine_path/$dir_elf; fi
			## define download source and packages
			dl_address_0="https://dl.winehq.org/wine-builds/fedora/$dist_dl_ver/$http_elf"
			dl_address_1="https://dl.winehq.org/wine-builds/fedora/$dist_dl_ver/i686"
			dl_list=(
				"$dl_address_0/wine-staging$b_elf-$pkg_ver-$pkg_rel.$http_elf.rpm"
				"$dl_address_1/wine-staging-common-$pkg_ver-$pkg_rel.i686.rpm"
			)
			unpack_list=(
				"wine-staging$b_elf-$pkg_ver-$pkg_rel.$http_elf.rpm"
				"wine-staging-common-$pkg_ver-$pkg_rel.i686.rpm"
			)
			## download command
			dl_cmd(){ wget -P $dl_dir $pkgs 2>&1; }
			## This perl regex Analyse and parse wget stdout field, then display it in a yad window
			track(){ perl -p -e "$| = 1; s/^.* +([0-9]+%) +([0-9,.]+[GMKB]) +([0-9hms,.]+).*$/\1\n# $pack_name [\1] time left: \3\t\2\/s/"; }
			## now download
			cd $dl_dir
			for pkgs in ${dl_list[@]}; do
				pack_name=$wine_ver
				## download UI feeds
				pkg_ext=$(printf "$pkgs"| sed -n "s/^.*\.//p")
				site=$(printf "$pkgs"| sed -E -n "s/(^.*:\/\/)(\w+)\.(\w+)\.(\w+)\/.*$/\2.\3.\4/p")
				pack=$(printf "$pkgs"| sed -n "s/^.*\///p")
				w_text="$vb\\Downloading $pack\\nfrom $site server.$end"
				## download progress bar UI
				dl_cmd | track | $yad_bin --width=550 --title "$w_title" --align=center --borders=$borders \
				--text="$w_text" --window-icon=filesave --image=$img_install --progress --auto-close
				if [ $? = 1 ]; then exit 0; fi
			done
			## then, extract to wine bin directory
			if [ $(ls -1 $dl_dir| egrep -c "$pkg_ver") -gt 0 ]; then
				for dwld in ${unpack_list[@]}; do
					e_text="$vb\\Extracting $dwld to $wine_path.$end"
					$yad_bin --width=550 --title "$w_title" --align=center --no-buttons --borders=$borders \
					--window-icon=filesave --progress --pulsate --auto-close --text="$e_text" \
					--progress-text="" &
					## seek the extrat UI yad PID
					WAIT_UI=$(ps -A | grep "yad" | awk '{print $1}'| sed -n '1p')
					## extract rpm command through rpm2cpio
					$rpm_bin $dwld | cpio -id
					kill $WAIT_UI
				done
				mkdir -p $wine_path/$dir_elf/$wine_ver/
				cp -Rf opt/wine-staging/* $wine_path/$dir_elf/$wine_ver/
				if [ $b_elf = 64 ]; then cd $wine_path/x86; ln -sf ../$dir_elf/$wine_ver ; fi
			fi
		else
			wine_ver=$(printf "$wine_bin_output"| cut -d';' -f5)
		fi

		## set if Wine env have to be set as default or not.
		if [[ $wine_64 == TRUE ]]; then wine_elf=1; else wine_elf=0; fi
		if [[ $wine_default == TRUE ]]; then printf "$wine_ver;$wine_path;$wine_elf" \
		> $HOME/.winestarter/default-wine; fi
	}
	fn_tricks_list_build(){
		if [ -x "$w_tricks_bin" ]; then
			w_tricks_reserve=$HOME/.winestarter/resources/tricks_workaround.txt
			w_tricks_dlls=$HOME/.winestarter/resources/tricks_dlls.txt
			if [[ -d $user_prefix/$bottle_prefix || $from_config = 1 ]]; then
				## let some time to winetricks to start building its list,
				## otherwise it could be confused during tab creation phase. 
				wait_message='BUILDING WINETRICKS LIST'
				on_top='--on-top '
				if ! [[ -s $w_tricks_reserve || -s $w_tricks_dlls ]]; then
					fn_plz_wait &
					WAIT_UI_3=$(ps -A | grep "yad" | awk '{print $1}'| sed -n '1p')
					sleep 1
					## set default arch
					if [ $wine_elf = 1 ]; then winearch='win64'; else winearch='win32'; fi
					## set default env
					export WINEARCH=$winearch
					export WINEPREFIX="$user_prefix/$bottle_prefix"
					## now look for winetricks settable dlls and put them in a tmp file
					$w_tricks_bin dlls list| grep "downloadable" >$w_tricks_dlls
					## create winetricks workaround list for winetricks log filtering
					$w_tricks_bin settings list|sed -n "/^---/,/---$/d;p"| egrep -v "^Using.*$"| \
					awk '{print $1}' >$w_tricks_reserve
					kill $WAIT_UI_3
				fi
			fi
			dlls_list=$(cat $w_tricks_dlls| awk '{print $1}'| tr '\n' ',')
		fi
	}
	fn_basics_config(){
		unset  tab_set tab_temp cfg_set t_display form_win 
		# launch default start window
		w_title="Winestarter"
		main_tab_text="$bf Configure Wine initial sets$end$nf\\n \
 It will create a basic Wine bottle, mainly useful if you plan to use an already\\n \
 existing app directory.$end"
		_wine=1
		tab_set=("1;_wfirst;Basics;fn_wine_basics;$img_wine_desk_ui")
		item_sep=","
		# window style and function
		win_type=1
		# create main window variables
		default_tab_create
	}
	fn_wine_basics(){
		echo -e "$g_notif\n>>>> start fn_wine_basics ####\n$e_notif"
		unset basic_sets track_list # #
		# window messages
		w_wine_basic_tip=""
		w_wine_user_prefix="$vb\\Set user prefix if not the user's default one:$end"
		w_wine_prefix="$vb\\Set the Wine Bottle prefix to use:$end"
		w_wine_prefix_tip="$vb\\Example:$end$nf wine.my_bottle$end, no space. \"$nf\\wine.$end\" prefix is mandatory."
		w_wine_game_path="$vb\\Set the full game/appli directory if different from bottle:$end"
		w_wine_elf_tip="$nf\\Note:$end 32bits apps can be launch from a Wine 64bits install (from Wine 2.0 and above). In my own experience, it enhance globaly app performances. (Don't for XP 32bits apps)"
		w_text="$bf\\Configure the Wine basic environment$end"
		
		track_list="user_prefix bottle_prefix game_path wine_elf"

		for trk_set in ${track_list[@]}; do
			unset local_set
			if [[ $trk_set == wine_elf ]]; then trk_box=0; else trk_box="$HOME/"; fi
			local_set+=("$trk_set=$trk_box")
			local $local_set
		done
		
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		basic_sets="'';;;;LBL;;
'';;;$w_wine_user_prefix;LBL;;
$user_prefix;user_prefix;;$nf Default Wine user prefix$end;DIR;;
'';;;$w_wine_prefix;LBL;;
'';;;$w_wine_prefix_tip;LBL;;
wine.mybottlename;bottle_prefix;;$nf Bottle prefix$end;;;
'';;;$w_wine_game_path;LBL;;
$game_path;game_path;;$nf Existing appli path$end;DIR;;
'';;;$w_wine_elf;LBL;;
'';;;$w_wine_elf_tip;LBL;;
$wine_elf;wine_elf;;App type is 64 bits;CHK;;"
		item_sep=","
		IFS=$ifs
		from_config=0
		focus='--focus-field=6'
		# window style and function
		win_type=1
		default_win_design
	}

	fn_wine_elf_query(){
		## if there is no initial wine install in the the system, try to set env first
		## when wine bottle is created at first step, define the wine arch used.
		if [ $wine_elf = 1 ]; then
			elf=64; elf_ext=' (x86)'; w_elf_ext='\ (86)'
		else
			elf=32; elf_ext=''; w_elf_ext=''
		fi
		if ! [ -d $user_prefix/$bottle_prefix/drive_c/Program\ Files"$elf_ext" ]; then
			root_key=''
		else
			root_key="Program Files$elf_ext/"
		fi
	}
	## at first launch for a botlle creation, sets the basics variables to access
	## custom path dirs and new Wine dirs
	fn_wine_basic_feed(){
		echo -e "$g_notif\n>>>> start fn_wine_basic_feed ####\n$e_notif"
		## initial bottle set before launching main features
		# ';;/home/mike;;;wine.botlle;;/home/games/FFXIV/SquareEnix;;;TRUE;'
		unset basic_list
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		basic_list=('user_prefix,3' 'bottle_prefix,6' 'game_path,8' 'wine_elf,11')
		basic_conf=$(cat $temp_b)
		## get back fn_wine_basic_feed data in case they come from an initial set. 
		for basic in ${basic_list[@]}; do
			unset basic_values
			basic_var=$(printf "$basic"|cut -d',' -f1)
			basic_rank=$(printf "$basic"|cut -d',' -f2)
			basic_val=$(printf "$basic_conf"| cut -d';' -f$basic_rank)
			if [[ $basic_val =~ ^[A-Z]+ ]]; then
				if [ $basic_val = 'TRUE' ]; then basic_val=1; else basic_val=0; fi
			fi
			if [ $basic_var = 'bottle_prefix' ]; then
				basic_val=.$basic_val
			fi
			basic_values=($basic_var=$basic_val)
			local "${basic_values}" 
		done
		
		## set default arch
		if [ $wine_elf = 1 ]; then winearch='win64'; else winearch='win32'; fi
		## set default env
		export WINEARCH=$winearch
		export WINEPREFIX="$user_prefix/$bottle_prefix"
		${wine_bin_path}wineboot -i
		fn_wine_elf_query
		
		
		if [[ $game_path != '' && $game_path != $HOME ]]; then
			link=$(printf "$game_path"| sed -n "s/^.*\///g;p")
			ln -sf $game_path $user_prefix/$bottle_prefix/drive_c/$root_key
			game_dir=$user_prefix/$bottle_prefix/drive_c/$root_key$link
			game_exe=$user_prefix/$bottle_prefix/drive_c/$root_key$link
		else
			game_dir=$user_prefix/$bottle_prefix/drive_c/$root_key
			game_exe=$user_prefix/$bottle_prefix/drive_c/$root_key	
		fi
		IFS=$ifs
		fn_create_prefix

	}

	fn_wine_config(){
		echo -e "$g_notif >>>> start fn_wine_config $e_notif"
		unset  basic_sets misc_sets def_args
		# check install elf type
		fn_wine_elf_query		
		# check already setted variables, if any.
		chk_arg_opts(){
#			ifs=$IFS
#			IFS=$(echo -en "\n\b")
			def_args=( $(cat $HOME/.winestarter/resources/options.list) )
			w_args_list=$(echo "$wine_opts"|tr '\ ' '\n')
			for val in ${def_args[@]}; do
				_arg=$(printf "$val"| cut -d';' -f1)
				_def=$(printf "$val"| cut -d';' -f2)
				if [ $(printf "$_arg"| egrep -c "[[:punct:]]") -gt 0 ]; then
					_short=$(printf "$_arg"| sed -nE "s/^.*[[:punct:]](\w*[a-z]$)/\1/p")
				else
					_short="$_arg"
				fi
				_var=("wine_arg_$_short")
				if [[ $_arg != misc ]]; then
					if [ $(echo "$wine_opts"| grep -Fc "$_arg") -gt 0 ]; then
						_def_arg='1'
						_rev_pat+=("$_arg")
					else
						_def_arg='0'
					fi
					## add field for each listed options in options.list
					# "23;$wine_arg_sdx;wine_arg_sdx;;$w_wine_cmd_sdx;CHK;;;"
					cmd_line_opts+=("$_def_arg;$_var;;$_def ($_arg);CHK;;")
					reconf_list+=("$_short;$_arg;$_var;$_def_arg")
				fi	
				if [[ $_arg == misc ]]; then
					## go back to default IFS temporarly.
					IFS=$ifs
					for _patt in $w_args_list; do
						sed_conv=$(echo "$_patt"| sed -n "s/^-//p")
						if [ $(echo -e "${_rev_pat[@]}"| egrep -c "$sed_conv") -eq 0 ]; then
							_arg_msc+=($_patt)
						fi
					done
					wine_arg_msc="\\$(echo "${_arg_msc[*]}")"
					if [ $(echo "$wine_arg_msc"| egrep -cx '^\\$') -eq 1 ]; then
						wine_arg_msc='unset'
					fi
					ifs=$IFS
					IFS=$(echo -en "\n\b")
				fi
			done
		}
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		if [ $from_config = 1 ]; then
			if [[ $game_dir != '' ]]; then
				if [ -d $user_prefix/$bottle_prefix/drive_c/$game_dir ]; then
					game_dir="$user_prefix/$bottle_prefix/drive_c/$game_dir"
				else
					game_dir="$user_prefix/$bottle_prefix/drive_c/Program Files$elf_ext/$game_dir"
				fi
				game_exe="$game_dir/$game_exe"
			else
				if [ -d $user_prefix/$bottle_prefix/drive_c/'Program Files'$elf_ext ]; then
					game_dir=$user_prefix/$bottle_prefix/drive_c/'Program Files'$elf_ext
					game_exe=$game_dir
				else
					game_dir=$HOME
					game_exe=$game_dir
				fi
			fi
			if [[ $game_path == '' ]]; then game_path="$HOME/"; fi
			if [ $_extended = 1 ]; then chk_arg_opts; fi
		else
			app_portable='FALSE'
			special_cmd='FALSE'
			start_cmd='FALSE'
			if ! [ -d $game_path ]; then game_path="$user_prefix"; fi
			if [ $_extended = 1 ]; then chk_arg_opts; fi
		fi
		
		## set the wine options files in resources and bottle
		export option_log=$user_prefix/$bottle_prefix/options.log
		export option_conf=$HOME/.winestarter/resources/options.list
		## tell to main script the last options conf modification time in EPOC at this point.
		if [ -s $option_log ]; then
			_option_log_pre=$(stat -c %Y $option_log )
		else
			_option_log_pre=$(date +%s)
		fi
		## button command
		option_edit_cmd="bash $bash_opt \"edit_wine_options\""
		# window messages
		w_wine_user_prefix="$vb\\Set user prefix if not the user's default one:$end"
		w_wine_prefix="$vb\\Set the Wine Bottle prefix to use:$end"
		w_wine_prefix_tip="$nf\\\Ex:$end wine.my_bottle, no space and \"wine.\" suffix is mandatory."
		w_wine_game_path="$vb\\Set the full game/app path if different from bottle:$end"
		w_wine_game_dir="$vb\\Set full Wine style game/app directory:$end$vn (if already existing)$end"
		w_wine_game_exe="$vb\\Set the Wine game/app executable to launch:$end$vn (if already existing)$end"
		w_wine_portable="$vb\\Set if the game/app is portable or you wish to install an already existing path to the C: drive root:$end"
		w_wine_game_spl="$vb\\Set if the app have to be started from the app directory:$end"
		w_wine_elf_tip="$nf\\Note:$end The initial install is actually set to Wine $nf"$elf"Bits$end. If you would like a different install type, you need to create a new prefix."
		
		w_wine_cmd="$bf Wine or app command line arguments$end"
		w_wine_cmd_tip="$vb\\You can set here Wine specific command line options. It can come from Wine by itself or specific from the app.$end"
		w_wine_cmd_gl="Force OpenGL only (opengl)"
		w_wine_cmd_sdx="Prevent Steam bottle sandboxing (no-cef-sandbox)"
		w_wine_cmd_msc="$nf Custom cmdline argument$end"
		w_wine_cmd_note="$nf\\Note$end: winestarter will keep all working user commandline options in its user directory for future possible use. If your custom option(s) is fully working, you could add it to the default menu with the button below."
		elf=$elf
		basic_sets="'';;;;LBL;;
'';;;$w_wine_elf_tip;LBL;;
'';;;;LBL;;
'';;;$w_wine_user_prefix;LBL;;
$user_prefix;user_prefix;;$nf Default Wine user prefix$end\t\t;DIR;;
'';;;$w_wine_prefix;LBL;;
$user_prefix/$bottle_prefix;bottle_prefix;;$nf Bottle prefix$end;CDIR;;
'';;;$w_wine_game_path;LBL;;
$game_path;game_path;;$nf Existing appli path$end;DIR;;
'';;;$w_wine_game_dir;LBL;;
$game_dir;game_dir;;$nf Full Wine appli directory$end;DIR;;
'';;;$w_wine_game_exe;LBL;;
$game_exe;game_exe;;$nf EXE file$end;FL;;
'';;;$w_wine_portable;LBL;;
$app_portable;app_portable;;Portable app (or to be set at C: drive root);CHK;;
'';;;$w_wine_game_spl;LBL;;
$special_cmd;special_cmd;;execute binary file inside the directory;CHK;;
$start_cmd;start_cmd;;execute binary from absolute path (using Wine \"start\" command);CHK;;"
		## extended menu
		misc_sets="'';;;;LBL;;
'';;;$w_wine_cmd;LBL;;
'';;;$w_wine_cmd_tip;LBL;;
${cmd_line_opts[*]}
$wine_arg_msc;wine_arg_msc;;$w_wine_cmd_msc;;;
'';;;$w_wine_cmd_note;LBL;;
$option_edit_cmd;cmd;;$vb click here to edit options menu$end,$img_wine_mod;FBTN;;"
		if [ $_extended = 1 ]; then
			basic_sets="${basic_sets[@]}
${misc_sets[@]}"
		fi
		item_sep=","
		## restore temporarly IFS
		IFS=$ifs
		## window style and function
		win_type=1
		## focused field
		focus=''
		echo -e "$g_notif\n>>>> end fn_wine_config ####\n$e_notif"
		default_win_design
	}
	fn_wine_binary(){
		echo -e "$g_notif\n>>>> start fn_wine_binary ####\n$e_notif"
		unset basic_sets track_list 
		w_wine_use_winepath="$vb Set if you want to use a custom Wine binary path:$end"
		w_wine_binary_title="$vb\\You can choose and activate here a custom Wine binary directory. Some apps (particulary old ones) could need old Wine versions. Datas are provided by PlayOnLinux Wine server.$end"
		w_wine_wine_path="$vb Set full path of customs Wine binaries repository:$end"
		w_wine_wine_ver="$vb Set the custom Wine directory name:$end"
		w_wine_dl_info="$vb\\Here, you can set the download method for the custom Wine binary. You can choose between PlayOnLinux packages (for Wine older than 2.4) or WineHQ-staging packages (above 2.4).$end"
		w_wine_wine_pol="$vb Download a binary package from PlayOnLinux repo:$end"
		w_wine_wconfig="$vb\\When set, new Wine binary will setup new environment, this set will allow winecfg to start at boot:$end"
		w_text="$bf Configure an extra Wine binary path$end"
		## check already setted variables
		track_list=('use_winepath' 'wine_path' 'wine_ver')
		wineset_list=$track_list
		wine_bin_cmd="bash $bash_opt \"select_wine_bin\""
		wine_dis_cmd="bash $bash_opt \"select_wine_dis\""
		if [ $wine_elf = 1 ]; then dir_elf='amd64'; else dir_elf='x86'; fi
		if [ $from_config = 1 ]; then
			ifs=$IFS
			IFS=$(echo -en "\n\b")
			for trk_set in ${track_list[@]}; do
				eval trk_val='$'$trk_set
				case $trk_set in
					'use_winepath') [ $trk_val ]|| local $trk_set=0 ;;
					'wine_path') [[ $trk_val ]] || local $trk_set="$HOME/.winebin" ;;
					'wine_ver') if [[ $wine_ver =~ [0-9]{1,2}.[0-9]{1,2}.*$ ]]; then
						local $trk_set="$wine_path/$dir_elf/$wine_ver"
					else
						local $trk_set="$HOME/.winebin"
					fi ;;
					*) local $trk_set="$HOME/";;
				esac
			done 
#			if [[ $wine_ver != '' ]]; then wine_ver="$wine_path/$dir_elf/$wine_ver"; else wine_ver="$HOME/"; fi
#			if [[ $wine_path == '' ]]; then wine_path="$HOME/.winebin"; fi
#			if [[ $use_winepath == '' ]]; then use_winepath=0; fi
			IFS=$ifs
		else
#			if [ -s $HOME/.winestarter/default-wine ]; then
#				wine_path=$(cat $HOME/.winestarter/default_wine| cut -d';' f2)					
#				wine_elf=$(cat $HOME/.winestarter/default_wine| cut -d';' f3)
#				wine_ver=$wine_path/$wine_elf/$(cat $HOME/.winestarter/default_wine| cut -d';' f1)
#				use_winepath=1
#			else
			if ! [ -s $HOME/.winestarter/default-wine ]; then
				for trk_set in ${track_list[@]}; do
	#				unset local_set
					case $trk_set in
						'use_winepath') local $trk_set=0 ;;
						'wine_path'|'wine_ver') if [ -d $HOME/.winebin ]; then 
							local $trk_set="$HOME/.winebin"
						fi ;;
						*) local $trk_set="$HOME/" ;;
					esac
		
	#					if [[ $trk_set == use_winepath ]]; then trk_box=0; else trk_box="$HOME/"; fi
	#					if [[ $trk_set == wine_path ]]||[[ $trk_set == wine_ver ]]; then 
	#						if [ -d $HOME/.winebin ]; then trk_box="$HOME/.winebin"; else trk_box="$HOME/"; fi
	#					fi
	#					local_set+=("$trk_set=$trk_box")
	#					local $local_set
				done
			fi			
		fi
		export wine_path=$wine_path
		export wine_elf=$wine_elf
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		basic_sets="'';;;;LBL;;
'';;;$w_wine_binary_title;LBL;;
$use_winepath;use_winepath;;use Wine binaries path (default:$HOME/.winebin);CHK;;
'';;;$w_wine_wine_path;LBL;;
$wine_path;wine_path;;$nf Wine binaries dir\t\t\t\t$end;DIR;;
'';;;$w_wine_wine_ver;LBL;;
$wine_ver;wine_ver;;$nf Wine bin name$end;DIR;;
'';;;;LBL;;
'';;;$w_wine_dl_info;LBL;;
$wine_dis_cmd;cmd;;$vb click here to download from WineHQ staging$end,$img_winedis_bt;FBTN;;
$wine_bin_cmd;cmd;;$vb click here to download a PoL Wine package$end,$img_winepol_bt;FBTN;;
'';;;;LBL;;
'';;;$w_wine_wconfig;LBL;;
$w_config;w_config;;Start Winecfg at app launch;CHK;;"
		echo -e "$g_notif\n>>>> end fn_wine_binary ####\n$e_notif"
		IFS=$ifs
		item_sep=","
		# window style and function
		win_type=1
		## focused field
		focus=''
		default_win_design
	}
	fn_regedit_config(){
		echo -e "$g_notif\n>>>> start fn_regedit_config ####\n$e_notif"
		unset basic_sets misc_sets
		# config file preset
		nv_smi=$(find /usr/{bin,local/bin} -name nvidia-smi)
		if [ -x $nv_smi ]; then
#		if [ -x /usr/bin/nvidia-smi ]||[ -x /usr/local/bin/nvidia-smi ] ; then
			mem_set=$($nv_smi --query|grep -w "^.*Total.*[KMG]iB"|sed -n "s/^.*\ \([0-9]*\) [A-Z].*$/\1/;1p")
			x_mem='unset,'$mem_set
			mem_comment=$mem_set'Mo detected'
		else
			mem_set='unset'
			x_mem='unset'
			mem_comment=''
		fi
		vid_mem='128,256,512,768,1024,2048,3072,4096,6144'
		
		echo -e "$g_notif >>>> detect previous registry $e_notif"
		reg_file=$(mktemp --tmpdir reg1.XXXXXXXX)
		reg_key='HKEY_CURRENT_USER'
		if [ $from_config = 1 ]; then
			if [ $(printf "$user_reg"| grep -c "\[.*\]") -gt 0 ]; then
				extract_reg=$(cat $config_file| sed -n "/^user_reg='/,/'/p"| perl -pe "s|\n|*|g"| \
				sed -E -n "s|^.*='(.*)'.*$|\1|;s|\*|\n|g;s|\\\|\\\\\\\|g;p")
			else
				extract_reg='[HKEY_CURRENT_USER\\Software\\Wine\\Direct3D]'
			fi
			echo -e "$extract_reg\n" > $reg_file
			export reg_file=$reg_file
			user_reg=$(awk 'NF' $reg_file | tr '\n' '*' | sed -n "s/.$//;s|\\\|\\\\\\\|g;s|*|\\\n|g;p")
		else
			printf "[HKEY_CURRENT_USER\\\\Software\\\\Wine\\\\Direct3D]*\\\"<option_name>\\\"=\\\"<option_set>\\\"*" > $reg_file
			user_reg=$(cat $reg_file| sed -n "s/.$//;s|\\\|\\\\\\\|g;s|*|\\\n|g;p")
		fi
		# convert temp reg file data in usable variables
		reg_values=('StrictDrawOrdering' 'csmt' 'DirectDrawRenderer' 'OffscreenRenderingMode' \
		'UseGLSL' 'CheckFloatConstants' 'VideoMemorySize' 'Nonpower2Mode' 'RenderTargetLockMode' )
#		edit_button="bash $bash_opt \"edit_reg_bin\""
		for reg_var in ${reg_values[@]}; do
			unset reg_variable
			if [ -s $reg_file ]; then
				if [ $(cat $reg_file| grep -c "$reg_var") -gt 0 ]; then
					## check for 'dword' reg file line structure and convert to 'enable/disable' for UI.
					if [ $(cat $reg_file| grep "$reg_var"| grep -c "dword") -eq 0 ]; then
						reg_val=$(cat $reg_file| grep "$reg_var"| \
						sed -n "s|^\"\($reg_var\)\"=\"\(.*\)\"|\2|p")
						## check for video memory reg value. Then, move 'unset' value if needed
						if [ $reg_var == 'VideoMemorySize' ]; then
							if [ $reg_val -gt 0 ]; then
								x_mem=$reg_val
								if [ $mem_set != $reg_val ]; then vid_mem="$mem_set,$vid_mem"; fi
							fi
						fi
					else
						reg_val=$(cat $reg_file| grep "$reg_var"| \
						sed -n "s|^\"\($reg_var\)\"=dword:\(.*\)|\2|p")
						if [[ $reg_val == '00000000' ]]; then
							reg_val=('disabled'); else reg_val="enabled"
						fi
					fi
					local $reg_var\_unset=',unset'
				else
					reg_val='unset'
					local $reg_var\_unset=''
				fi
			else
				reg_val='unset'
			fi
			reg_variable+=($reg_var=$reg_val)
			local $reg_variable
		done
		if [ $_extended = 1 ]; then
			echo -e "$g_notif >>>> start extended features $e_notif"
			if [ -s $HOME/.winestarter/resources/mime-preset.lst ]; then
				res_mime_preset=$(cat $HOME/.winestarter/resources/mime-preset.lst| tr '\n' ','| \
				sed -n "s/,$//p")
			fi
			reg_log=$user_prefix/$bottle_prefix/dlls_reg.log
			if [ -s $reg_log ]; then
				unset dlls_var_list
				dll_base_list=("$(cat $reg_log| cut -d',' -f2)")				
				for dll_base in ${dll_base_list[@]}; do
					if [ $elf = 32 ]; then
						sys_elf='32'
						reg_field_list+=( "$dll_base" )
					else
						sys_elf='32/64'
						if [ $(echo "${reg_field_list[*]}"| egrep -c "$dll_base" ) -eq 0 ]; then
								reg_field_list+=( "$dll_base" )
						fi
					fi
				done
				reg_dlls_field=$(echo "${reg_field_list[*]}"| sed -n "s/\ /\, /g;p")
				reg_dll_msg="$vb\\Registered DLLs ($sys_elf):$end"
				dlls_var_list=( "'';;;$reg_dll_msg $reg_dlls_field;LBL;;" )
			fi
		fi
			
		# window messages
		w_text="$bf Edit the Wine registry$end\\n\
$vb\\Set here the most usual registry Direct3D graphic options$end\\n\
$vb\\or edit a file manualy (will be merge with others sets)$end" #\\n \
		w_reg_manual0="$rb\\WARNNG:$end$vn Direct3D registry config is only usable under WindowsXP bottle$end"
		w_reg_manual1="$vb Custom Direct3D registering (manual edit).$end"
		w_reg_manual2="$rb\\WARNING:$end$vn Don't remove lines set with the menu above, they will be kept anyway.$end"
		w_reg_manual3="$bf\\Unusual registry commands and options$end"

		w_reg_2_title="$bf\\Associate mime type to local system$end"
		w_reg_2_tip0="$vb\\In many case, user must install subsidiary software to run some file type directly from the bottle (avi, mp4, txt, doc, etc). You can set here those files types to be launch by your local system apps.$end"

		w_reg_2_warn0="$vn\\Files will be open with default xdg-open environment set$end"
		w_reg_2_setted="$vb\\Already associated:$end $(printf "$local_association"| sed -n 's/,/, /g;p')"
		w_reg_2_set_tip0="$vb\\Use presets or edit manually$end:$vn (will be added to presets)$end"
		w_reg_2_set_tip1="$rb\\WARNING$end$vn : When picked up from a directory, files types need to be of the same kind (mp4, avi or doc, odf, etc), this is mandatory.$end"
		w_reg_2_set_1="$nf Select one or more files for type$end"
		w_reg_2_set_2="$nf or pick a preset in the list$end"
		w_reg_2_set_4="Set local program to use"

		w_reg_3_tip0="$vb\\In some cases, it could be necessary to use specific system reg file, DLLs registration/unregistration to set properly a bottle.$end"
		w_reg_3_warn0="$rb\\WARNING$end$vn: Doing something nasty here can strongly compromise your bottle.$end"
		w_reg_3_titl0="$vb\\Register, unregister specific DLLs:$end"
		w_reg_3_cmd0="$nf Select the operation class$end"
		w_reg_3_cmd1="$nf Select the system type$end"
		w_reg_3_cmd2="$nf Select the DLL (one or more)$end"
		w_reg_3_tit1e="$vb\\Create a specific reg file$end"
		w_reg_3_cmd3="$nf Select the type$end"
		w_reg_3_cmd4="$vb\\Write the custom registration without the key line$end"
		w_reg_3_tip=""
		
		w_reg_def_SDO="$nf StrictDrawOrdering$end$vn\tbelow Wine 2.6$end"
		w_reg_def_CSMT="$nf CSMT$end$vn \t\t\t\tWine 2.6 and above$end"
#		w_reg_def_VID="$nf VideoMemorySize$end$vn     unset to not use$end"
		w_reg_def_VID="$nf VideoMemorySize$end$vn  $mem_comment$end"
#		w_reg_def_=""
#		w_reg_def_=""

		basic_sets="'';;;;LBL;;
'';;;$w_reg_manual0;LBL;;
$StrictDrawOrdering,enabled,disabled$StrictDrawOrdering_unset;StrictDrawOrdering;;$w_reg_def_SDO;CB;;
$csmt,enabled,disabled$csmt_unset;csmt;;$w_reg_def_CSMT;CB;;
$DirectDrawRenderer,opengl,gdi$DirectDrawRenderer_unset;DirectDrawRenderer;;$nf DirectDrawRenderer$end;CB;;
$OffscreenRenderingMode,backbuffer,fbo$OffscreenRenderingMode_unset;OffscreenRenderingMode;;$nf OffscreenRenderingMode$end;CB;;
$RenderTargetLockMode,auto,disabled,readdraw,readtex,texdraw,textex$RenderTargetLockMode_unset;RenderTargetLockMode;;$nf RenderTargetLockMode$end;CB;;
$UseGLSL,enabled,disabled$UseGLSL_unset;UseGLSL;;$nf UseGLSL$end;CB;;
$CheckFloatConstants,enabled,disabled$CheckFloatConstants_unset;CheckFloatConstants;;$nf CheckFloatConstants$end;CB;;
$Nonpower2Mode,repack;Nonpower2Mode$Nonpower2Mode_unset;;$nf Nonpower2Mode$end;CB;;
$x_mem,$vid_mem$VideoMemorySize_unset;VideoMemorySize;;$w_reg_def_VID;CBE;;
'';;;$w_reg_manual1;LBL;;
$user_reg;user_reg;;$w_reg_manual2;TXT;;"

		misc_sets="'';;;;LBL;;
'';;;$w_reg_2_title;LBL;;
'';;;$w_reg_2_tip0;LBL;;
'';;;$w_reg_2_warn0;LBL;;
'';;;$w_reg_2_set_tip1;LBL;;
'';;;$w_reg_2_set_tip0;LBL;;
'';;;$w_reg_2_setted;LBL;;
unset;Selected_Files;;$w_reg_2_set_1;MFL;;
unset,$res_mime_preset;mime_preset;;$w_reg_2_set_2;CB;;
'';;;;LBL;;
'';;;$w_reg_manual3;LBL;;
'';;;$w_reg_3_tip0;LBL;;
'';;;$w_reg_3_warn0;LBL;;
'';;;;LBL;;
'';;;$w_reg_3_titl0;LBL;;
${dlls_var_list[@]}
unset,register,unregister;dll_reg_type;;$w_reg_3_cmd0;CB;;
unset,wine32,wine64,both;dll_elf_type;;$w_reg_3_cmd1;CB;;
$user_prefix/$bottle_prefix/drive_c/windows;dll_file_list;;$w_reg_3_cmd2;MFL;;"
#		'';;;;LBL;;
#		'';;;$w_reg_3_title;LBL;;
#		unset,user,system;misc_reg_type;;$w_reg_3_cmd3;CB;;
#		;misc_reg_val;;$w_reg_3_cmd4;TXT;;"
#		${previous_reg_edit[@]}
#		$edit_button;user_reg;;$w_reg_manual1;FBTN;;"

		if [ $_extended = 1 ]; then
			basic_sets="${basic_sets[@]}
${misc_sets[@]}"
		fi
		echo -e "$g_notif\n>>>> end fn_regedit_config ####\n$e_notif"
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# create main window variables
	}
	fn_make_tricks_menu(){
		echo -e "$g_notif\n>>>> start fn_make_tricks_menu$e_notif"
		prim_file=$(mktemp --tmpdir trk1.XXXXXXXX)
		sec_file=$(mktemp --tmpdir trk2.XXXXXXXX)
		menu_file=$(mktemp --tmpdir trk3.XXXXXXXX)
		menu_conf=$(mktemp --tmpdir trk4.XXXXXXXX)
		
		unset prim_keywords sec_keywords
		
		## interpret temp file and create auto field for yad
#		wtricks_list=$HOME/.winestarter/resources/wtricks_dlls.list
#		wtricks_conf=$HOME/.winestarter/resources/wtricks_dlls.conf

#		if ! [ -e $wtricks_list ]; then touch $wtricks_list; fi
		## get a full regex of the winetricks dlls list output; then recompose later for good usage. 
		regex='(.*[0-9a-z])(\s*[\ ]{3,})(\w*[[:alnum:]].*)\ \((\w+.*), ([0-9]{4}|[0-9]{4}-[0-9]{4})\) \[((.*),(.*)|(.*))\]'
		prim_keywords=(
			"Microsoft,Most common Microsoft dlls packages (often mandatory):,1"
			"Nvidia,PHYSX Nvidia package: can be very useful to improve performances,0"
			"Adobe,Adobe softwares and plugins packages,0"
			"Apple,Apple softwares and plugins packages,0"
			"other,Other useful packages,0")
		sec_keywords=(
			"d3dx;Direct3D packages\$rb ( DX11 only available for Win7 and above)\$end"
			"xact;Xact is mostly needed for Direct3D 9 packages"
			"gdi;GDI+, core Graphic Device Interface rendering"
			"msxml;Microsoft XML Core Services"
			"dotnet;NET packages for Wine Mono replacement"
			"mfc;MS Foundation Class (mfc), often called by Visual C++ apps"
			"vcrun;Visual C++ runtime libraries (vcrun)"
			"vb[0-9]run;Visual Basic runtime libraries (vbrun)"
			"ie[0-9];IE packs in case GECKO mozilla package failed to load HTML pages"
			"rich;RichEdit Control"
			"other;Other Microsoft dlls")
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		echo "basic_sets=\"" > $menu_conf 
		echo "'';;;\$w_tricks_ald_list;LBL;;
'';;;\$w_tricks_cache;LBL;;
'';;;;LBL;;" > $menu_file
#		real_n='3'
		sed -ni "s/;/:/i;p" $w_tricks_dlls
		if [ $(cat $w_tricks_dlls| grep -wc "(.*,.*,.*,.*,.*).*(.*)") -gt 0 ]; then
			trk_recompose=$(cat $w_tricks_dlls| grep -w "(.*,.*,.*,.*,.*).*(.*)"| awk '{print $1}')
			for _recompose in ${trk_recompose}; do
				sed -ni "s/\($_recompose[ ]\+\) \(.*\) \((.*)\)\(.*\)\((.*)\)\(.*\)/\1 \2\4\5\6/i;p" \
				$w_tricks_dlls
			done
		fi
		## first isolate each part by keyword	
		for _all in ${prim_keywords[@]}; do
			_prim_key=$(printf "$_all"| cut -d',' -f1)
			_prim_tip=$(printf "$_all"| cut -d',' -f2)
			_sec_key=$(printf "$_all"| cut -d',' -f3)
			printf "'';;;#$_prim_tip;LBL;;\n" >>$menu_file
			## if keyword has secondary keywords
			if [ $_sec_key -gt 0 ]; then
				## decompose primary list to get secondary keywords
				for _sec in ${sec_keywords[@]}; do
					cat $w_tricks_dlls| grep -F "$_prim_key" > $prim_file
					_sec_key=$(printf "$_sec"| cut -d';' -f1)
					_sec_desc=$(printf "$_sec"| cut -d';' -f2)
					printf "'';;;#$_sec_desc;LBL;;\n" >>$menu_file
					if [[ $rev_key != '' ]]; then _sec_rev='|'$_sec_key; else _sec_rev=$_sec_key; fi
					rev_key="$rev_key$_sec_rev"
					if [[ $_sec_key == other ]]; then
						cat $prim_file | egrep -v "\s*($rev_key)" > $sec_file
					else
						cat $prim_file | egrep "\s*^$_sec_key" > $sec_file
					fi
					compo_file=$sec_file
					cat $compo_file| sed -E -n "s/$regex/\$\1;\1;; \3 (\1, \5)\8;CHK;;/p" \
					>> $menu_file
				done
			else
				if [[ $_prim_key == other ]]; then
					cat $w_tricks_dlls | egrep -v "\s*($rev_prim)" > $prim_file
					_prim_key=''
				else
					cat $w_tricks_dlls | egrep "\s*$_prim_key" > $prim_file
				fi
				compo_file=$prim_file
				cat $compo_file| sed -E -n "s/$regex/\$\1;\1;; \3 (\1, \5)\8;CHK;;\1/p" \
				>> $menu_file
			fi
			if [[ $rev_prim != '' ]]; then _prim_rev='|'$_prim_key; else _prim_rev=$_prim_key; fi
			rev_prim="$rev_prim$_prim_rev"
		done
		
		echo "'';;;;LBL;;
'';;;\$w_tricks_winetricks;LBL;;
\$trk_action;;;\$w_tricks_trk_launch,\$img_tricks_bt;FBTN;;" >> $menu_file
		cat $menu_file >> $menu_conf
		## Insert span values in description fields
		sed -E -ni "s/^(.*;;;)#(\w*[A-Z].*)(;LBL)(.*)$/\1\$vb\\\\\\\\\\2\$end\3\4/i;p" \
		$menu_conf
		if [ $(cat $menu_conf| grep -Fc "cached") -gt 0 ]; then
			sed -E -ni "s/cached/*/gi;p" $menu_conf
		fi
		echo "\"" >> $menu_conf
		
		IFS=$ifs
		echo -e "$g_notif\n>>>> end fn_make_tricks_menu $e_notif"
	}
	fn_winetricks(){
		echo -e "$g_notif\n>>>> start fn_winetricks $e_notif"
		unset basic_sets track_list track_sets conf_dat
		unset prim_keywords sec_keywords
		w_tricks_dlls=$HOME/.winestarter/resources/tricks_dlls.txt
		
		track_list=$(cat "$w_tricks_dlls"| awk '{print $1}')
		winetricks_log=$user_prefix/$bottle_prefix/winetricks.log
		if [ $from_config = 1 ]; then
			if [ -s $winetricks_log ]; then
				tricks_log=$(mktemp --tmpdir tricks.XXXXXXXX)
				w_tricks_reserve=$scpt_dir/resources/tricks_workaround.txt
				w_filters=$(cat $w_tricks_reserve| tr '\n' '|')'w_workaround'
				cat $winetricks_log| egrep -v "$w_filters" >$tricks_log
				track_sets=$(cat $tricks_log| tr '\n' ' ')
#				track_sets=$(cat $tricks_log| tr '\n' ' ')
			else
				track_sets=$(printf "$w_tricks_list"|sed -n "s/^.*=\"//;s/\"$//g;p"|tr ',' '\ ')
			fi
		fi
		for trk_set in ${track_list[@]}; do
			if [ $from_config = 1 ]; then
#				conf_set=$(printf "${track_sets[@]}"| egrep -oc "$trk_set[ ]?")
				trk_box=$(printf "${track_sets[@]}"| egrep -wc "\s*$trk_set")
#				if [ $conf_set -gt 0 ]; then
#					trk_box=1
#				else
#					trk_box=0
#				fi
			else
				trk_box=0
			fi
			conf_dat+=("$trk_set=$trk_box")
		done
#		exit 0
		# create a list including extra install dlls from winetricks list
		if [ $from_config = 1 ]; then
			for trk_var in ${track_sets[@]}; do
				if [ $(printf "${track_list}"| grep -c "$trk_var") -eq 0 ];then
				extra_sets+=("$trk_var")
				fi
			done
		fi
		local "${conf_dat[@]}"
		# display already installed packages
		if [ $(printf "$w_tricks_list"| grep -c .) -gt 0 ]; then
			if [ -s $tricks_log && $(cat $tricks_log| grep -c .) -gt 0 ]; then
#			if [ -s $tricks_log ]; then
#				already_there=$(echo "${track_sets[*]}"| sed -n "s/ /, /g;s/, $//p")
				already_there=$(cat $tricks_log| tr '\n' '*'| sed -n "s/[*]\{1,2\}$//;s/*/, /g;p")
			else
				already_there=$(echo "$w_tricks_list"| sed -n "s/,/, /g;p")
			fi
		else
			already_there='none'
		fi
		# window messages
		w_text="$bf Winetricks common apps and DLLs$end\\n$vb\\Set the most common Windows packages available in Winetricks needed by your app.$end"
		w_tricks_alt_dot4_tip="$nf\\Note$end: .NET 4.x need an extra additional packges for clean install. Follow Winetrciks instruction during install without stopping the process."
		w_tricks_winetricks="$bf More from Winetricks$end"
		w_tricks_trk_launch="$vb Click to launch Winetricks separatly$end"
		w_tricks_trk_dll="$vb\\or launch Winetricks$end $nf(one or more packages)$end"
		w_tricks_trk_dlls="$vb Add an additional DLL component$end"
		w_tricks_ald_list="$vb\\Already installed:$end $already_there"
		w_tricks_cache="$nf\\Note:$end All packeges marked with a \* are already cached."
		fn_make_tricks_menu
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		# var list sets
		trk_action="bash $bash_opt \"$w_tricks_bin --gui &>/dev/null\""
		. $menu_conf
		echo -e "$g_notif\n>>>> end fn_winetricks ####\n$e_notif"
		IFS=$ifs
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
#		exit 0
		default_win_design
		# window style and function
	}
	fn_install_soft(){
		echo -e "$g_notif\n>>>> start fn_install_soft ####\n$e_notif"
		unset  basic_sets misc_sets track_list
		
		pkgs_log=$user_prefix/$bottle_prefix/packages.log
		extra_log=$user_prefix/$bottle_prefix/extra_pcks.log
		track_list=('w_install_exe' 'w_exe_path' 'w_tricks_opts' 'w_more_pkgs' 'w_install_zip' 'w_install_dir' 'w_download_dir' 'w_extra_script')

		for _var in ${track_list[@]}; do
			eval _listed='$'$_var
			case $_var in
				'w_install_exe') w_install_exe=0 ;;
				'w_tricks_opts') if [[ $_listed != '' ]]; then local $_var=1; else local $_var=0; fi ;;
				'w_exe_path') if [ -s $pkgs_log ]; then
						exe_log=$(cat $pkgs_log| tr '\n' ','| sed -n "s/,$//p")
						if [ $(cat $pkgs_log| grep -c "$_listed") -gt 0 ]; then _listed="$HOME/"; fi
					else
						exe_log='none'
						if ! [[ $_listed ]]; then _listed="$HOME/"; fi
					fi
					local $_var="$_listed" ;;
				'w_more_pkgs')
					if [[ $_listed ]]; then
						if [ $(cat $config_file| sed -n "/^w_more_pkgs/,/'$/p"| grep -c . ) -gt 1 ]; then
							_listed=$(cat $config_file| sed -n "/^w_more_pkgs/,/'$/p"| tr '\n' ','| \
							sed -En "s/^.*='(.*)',/\1/p")
#							_listed=$(echo -e "$_multiline"| tr)
#							local "$_listed"
						fi
					fi
					if [ -s $extra_log ]; then
						more_log=$(cat $extra_log| tr '\n' ',')
						if [[ $_listed ]]; then
							more_list=( $(echo -e "$_listed"| tr ',' '\n') )
							for _more in ${more_list[*]}; do
								if [ $(cat $extra_log| grep -c "$_more") -eq 0 ]; then
									_mod_list+=("$_more,")
								fi
							done
							_listed=$(echo "${_mod_list[@]}"| sed -n "s/,$//g;p")
						else
							_listed="$HOME/"
						fi
					else
						more_log='none'
						if ! [[ $_listed ]]; then _listed="$HOME/"; fi
					fi
					local $_var="$_listed" ;;
				'w_download_dir') local $_var=$XDG_DOWNLOAD_DIR/ ;;
				*) local $_var="$HOME/" ;;
			esac
		done
		
		# window messages
		w_text="$bf\\Software install$end\\n\
$vb\\This feature allow you to install a software at WineStarter launch$end\\n\
$vb\\It will work in most cases, but could fail before the end of process$end\n\
$nf\\TIP:$end For downloading, you can replace file name path by internet URL."
		w_tricks_trk_exe="check here to activate install process"
		w_tricks_ins_exe="$nf Select the .exe/.msi package to install$end"
		w_tricks_trk_opt="$vb Winetricks command line options:$end"
		w_tricks_trk_opt0="option (--no-isolate): force Winetricks to not create its own prefix"
		w_tricks_trk_tip0="$vb\\User prefix and wine bottle have to be already set in Wine tab.$end"
		w_tricks_trk_tip1="$nf\\Note:$end Steam Winetricks package is usualy broken, download it by your own if needed."
		w_tricks_info0="$nf\\Already installed:$end $exe_log."
		w_tricks_info1="$nf\\Already installed:$end $more_log."
		w_more_pkgs0="$bf\\More packages$end"
		w_more_pkgs1="$vb\\If you have to install associated package or other dlls from separate source and not available in Winetricks, select them here$end"
		w_more_pkgs2="$nf Select one or more$end"
		w_more_zip0="$bf\\Alternative install type$end"
		w_more_zip1="$vb\\In some cases, install is provided by a compressed file (zip, rar, 7z, exe) extracted or to extract directly to the bottle Program File directory. Manage them here.$end"
		w_more_zip2="$nf\\Note$end: for auto-extractible exe file, create the directory first. Name with a '$nf-$end' after the first word will be auto-detected."
		w_more_zip3="$nf Select the compressed file to install$end"
		w_more_zip4="$nf Select or create the target directory$end"
		w_more_dl0="$bf\\Download directory option$end"
		w_more_dl1="$vb\\By default, download will be stored in user default dowload directory. You can set a different one here.$end"
		w_more_dl2="$nf Select dowload directory$end"
		w_more_scpt0="$bf\\User script$end"
		w_more_scpt1="$vb\\In very rare case, some users wish to add script to their app directory (updator,log collector, etc), this is the place to do so.$end"
		w_more_scpt2="$rb\\WARNING$end:$nf Choose wisely, this is at your own risk.$end"
		w_more_scpt3="$nf Select a script (bash, python, etc) $end"
			
		pre_list=0
		# var list sets
		basic_sets="'';;;;LBL;;
'';;;$w_tricks_trk_tip1;LBL;;
'';;;$w_tricks_trk_tip0;LBL;;
'';;;;LBL;;
$w_install_exe;w_install_exe;;$w_tricks_trk_exe;CHK;;
'';;;;LBL;;
'';;;$w_tricks_info0;LBL;;
$w_exe_path;w_exe_path;;$w_tricks_ins_exe;MFL;;_w_soft
'';;;;LBL;;
'';;;$w_tricks_trk_opt;LBL;;
$w_tricks_opts;w_tricks_opts;;$w_tricks_trk_opt0;CHK;;
'';;;;LBL;;
'';;;$w_more_pkgs0;LBL;;
'';;;$w_more_pkgs1;LBL;;
'';;;$w_tricks_info1;LBL;;
$w_more_pkgs;w_more_pkgs;;$w_more_pkgs2;MFL;;
'';;;;LBL;;
'';;;$w_more_zip0;LBL;;
'';;;$w_more_zip1;LBL;;
'';;;$w_more_zip2;LBL;;
$w_install_zip;w_install_zip;;$w_more_zip3;MFL;;
$w_install_dir;w_install_dir;;$w_more_zip4;CDIR;;
'';;;;LBL;;
'';;;$w_more_dl0;LBL;;
'';;;$w_more_dl1;LBL;;
$w_download_dir;w_download_dir;;$w_more_dl2;CDIR;;"

		misc_sets="'';;;;LBL;;
'';;;$w_more_scpt0;LBL;;
'';;;$w_more_scpt1;LBL;;
'';;;$w_more_scpt2;LBL;;
$w_extra_script;w_extra_script;;$w_more_scpt3;FL;;"
		if [ $_extended = 1 ]; then
		basic_sets="${basic_sets[@]}
${misc_sets[@]}"
		fi
		echo -e "$g_notif\n>>>> end fn_install_soft ####\n$e_notif"
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# window style and function
	}
	fn_nvidia_config_1(){
		echo -e "$g_notif\n>>>> start fn_nvidia_config_1 ####\n$e_notif"
		unset basic_sets track_list #
		# window messages
		w_nv_tip0="$vb All variable are unset by default. (0) mean 'off' (1) means 'on'.$end"
		w_nv_fsaamod0="$vb Full Scene Anti Aliasing, from 0 (off) to 5 (16x) : (1) 2x (2xMS), (2) 4x (4xMS), (3) 8x (4xSS/2xMS), (4) 8x (8xMS), (5) 16x (4xSS/4xMS)$end"
		w_nv_fsaactrl0="$vb If set, FSAA comes with 2 others arguments:$end"
		w_nv_fsaactrl1="$nf Full controlled, enhanced if using multisample or ignored (manage by nvidia-setting)$end"
		w_nv_fxaa0="$vb This will allow (not force) Fast Approximate Antialiasing: multisampling and supersampling methods$end"
		w_nv_aniso="$vb Anisotropic texture filtering set: off (0), x2 (1), x4 (2), x8 (3), x16 (4)$end"
		w_nv_vblank="$vb Synchronize vertical diplay refresh$end"
		w_nv_thread="$vb Libpthread is not usualy enable in Wine, you can force it to prelaod$end"
		w_nv_perf="$vb Performance can be set between Quality(1), Mixed(2) Performance(3)$end"

		# check already setted variables
		if [ $from_config = 1 ]; then
			if [ $__GL_FSAA_MODE -gt 0 ]; then
				case $__GL_FSAA_MODE in
					'5') __GL_FSAA_MODE=2;;
					'9') __GL_FSAA_MODE=3;;
					'10') __GL_FSAA_MODE=4;;
					'11') __GL_FSAA_MODE=5;;
				esac
				if [ $__GL_FSAAAppControlled = 0 ]&&[ $__GL_FSAAAppEnhanced = 0 ]; then
					__GL_FSAA_CTRL='full control'
				elif [ $__GL_FSAAAppControlled = 0 ]&&[ $__GL_FSAAAppEnhanced = 1 ]; then
					__GL_FSAA_CTRL='enhanced'
				elif [ $__GL_FSAAAppControlled = 1 ]&&[ $__GL_FSAAAppEnhanced = 1 ]; then
					__GL_FSAA_CTRL='ignored'
				else
					__GL_FSAA_CTRL='unset'
				fi
			else
				__GL_FSAA_CTRL='unset'
			fi
		else
			__GL_FSAA_CTRL='unset'
		fi
		
		track_list=(
		"__GL_FSAA_MODE"
		"__GL_ALLOW_FXAA_USAGE"
		"__GL_LOG_MAX_ANISO"
		"__GL_SYNC_TO_VBLANK"
		"__GL_THREADED_OPTIMIZATIONS"
		"__GL_OpenGLImageSettings")
		for trk_set in ${track_list[@]}; do
			eval trk_field='$'$trk_set
			if [[ $trk_field == '' ]]; then
				local $trk_set='unset'
			fi
		done
		# var list sets
		w_title="Wine Start Config"
		w_text="$bf Configure Nvidia OpenGL options$end"
		basic_sets="'';;;$w_nv_tip0;LBL;;
'';;;;LBL;;
'';;;$w_nv_fsaamod0;LBL;;
$__GL_FSAA_MODE,0..5;__GL_FSAA_MODE;;$nf Full scene antialiasing$end;NUM;;
'';;;$w_nv_fsaactrl0;LBL;;
'';;;$w_nv_fsaactrl1;LBL;;
$__GL_FSAA_CTRL,full control,enhanced,ignored;__GL_FSAAA_CTRL;;$nf FSAA control type$end;CB;;
'';;;$w_nv_fxaa0;LBL;;
$__GL_ALLOW_FXAA_USAGE,0,1;__GL_ALLOW_FXAA_USAGE;;$nf Fast approximate antialiasing (FXAA)\t$end;CB;;
'';;;$w_nv_aniso;LBL;;
$__GL_LOG_MAX_ANISO,0..4;__GL_LOG_MAX_ANISO;;$nf Anisotropic texture filtering$end;NUM;;
'';;;$w_nv_vblank;LBL;;
$__GL_SYNC_TO_VBLANK,0,1;__GL_SYNC_TO_VBLANK;;$nf Sync to VBLANK$end;CB;;
'';;;$w_nv_thread;LBL;;
$__GL_THREADED_OPTIMIZATIONS,0,1;__GL_THREADED_OPTIMIZATIONS;;$nf Preload libpthread$end;CB;;
'';;;$w_nv_perf;LBL;;
$__GL_OpenGLImageSettings,1,2,3;__GL_OpenGLImageSettings;;$nf Nvidia graphic Performance set$end;CB;;"
		echo -e "$g_notif\n>>>> end fn_nvidia_config_1 ####\n$e_notif"
		
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# window style and function
	}
	fn_nvidia_config_2(){
		echo -e "$g_notif\n>>>> start fn_nvidia_config_2 ####\n$e_notif"
		unset basic_sets track_list  #
		# window messages
		w_nv_tip0="$vb All variable are unset by default. (0) mean 'off' (1) means 'on'.$end"
		w_nv_display="$vb VBLANK can't bet set separatly when using multi screen, choose one here if needed:$end"
		w_nv_fbconfig="$vb This set the X server FBconfig behaviour (very optional):$end"
		w_nv_yield0="$vb Updating window moves yield: can be useful if some window has refresh issues:$end"
		w_nv_yield1="$nf normal yield (''), no yield (NOTHING), background (USLEEP)$end"
		w_nv_unofficial0="$vb Allow unofficial GLX implementation from appli (very optional):$end"
		w_nv_gsync="$vb If monitor can manage G-SYNC behaviour, this option could improve performance:$end"
		w_nv_glsl0="$vb This option permit to recompile GLSL and could be useful if appli is missing some extension in OpenGL sets:$end"
		# use 'get_xrandr_list' to set the connected monitor list.
		monitors_list=$(printf "${connect_[@]}"|tr '\n' '#')
		# check already setted variables
		track_list=(
		"__GL_SYNC_DISPLAY_DEVICE"
		"__GL_SORT_FBCONFIGS"
		"__GL_YIELD"
		"__GL_ALLOW_UNOFFICIAL_PROTOCOL"
		"__GL_GSYNC_ALLOWED"
		"__GL_IGNORE_GLSL_EXT_REQS")
		for trk_set in ${track_list[@]}; do
			eval trk_field='$'$trk_set
			if [[ $trk_field == '' ]]; then
				local $trk_set='unset'
			fi	
		done
		# var list sets
		w_title="Wine Start Config"
		w_text="$bf Configure extended Nvidia display options$end"
		basic_sets="'';;;$w_nv_tip0;LBL;;
'';;;;LBL;;
'';;;$w_nv_display;LBL;;
$__GL_SYNC_DISPLAY_DEVICE,$monitors_list;__GL_SYNC_DISPLAY_DEVICE;;$nf VSync display$end;CB;;
'';;;$w_nv_fbconfig;LBL;;
$__GL_SORT_FBCONFIGS,0,1;__GL_SORT_FBCONFIGS;;$nf Xorg FBconfig$end;CB;;
'';;;$w_nv_yield0;LBL;;
'';;;$w_nv_yield1;LBL;;
$__GL_YIELD,normal,NOTHING,USLEEP;__GL_YIELD;;$nf Window yield:$end;CB;;
'';;;$w_nv_unofficial0;LBL;;
$__GL_ALLOW_UNOFFICIAL_PROTOCOL,0,1;__GL_ALLOW_UNOFFICIAL_PROTOCOL;;$nf Unofficial OpenGL implementation$end\t\t\t;CB;;
'';;;$w_nv_gsync;LBL;;
$__GL_GSYNC_ALLOWED,0,1;__GL_GSYNC_ALLOWED;;$nf G-Sync$end;CB;;
'';;;$w_nv_glsl0;LBL;;
$__GL_IGNORE_GLSL_EXT_REQS,0,1;__GL_IGNORE_GLSL_EXT_REQS;;$nf Ignore GLGS extension check$end;CB;;"
		echo -e "$g_notif\n>>>> end fn_nvidia_config_2 ####\n$e_notif"
		
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# window style and function
	}
	# base display auto-detection scripts
	get_xrandr_list(){
			echo -e "$g_notif >>>> get_xrandr_list$e_notif"
			unset display_ connect_ dsp_vars dsp_res_ dsp_res_list
			ifs=$IFS
			IFS=$(echo -en "\n\b")
			# give the list of connected monitors with all details
			connected_list=$(xrandr --current| grep "connected"|grep -v "disconnected")
			# give the actual primery resolution 
			current_res=$(xrandr --current| fgrep "*"| awk '{print $1}')
			n=0
			# dispatch display list in variables
			for dsp0 in ${connected_list[@]}; do
				# monitors system name
				_dsp=$(printf "$dsp0"| awk '{print $1}')
				# detect if it is primary or not
				_prm=$(printf "$dsp0"| grep -c "primary")
				# give the actual monitor resolution
				_def=$(printf "$dsp0"| grep -o "\(\w*[0-9]\{3,4\}[x]\w*[0-9]\{3,4\}\)")
				# set each monitor as variable
				display_+=("DSP_$n=$_dsp")
				# set a usable list of connected monitors
				connect_+=("$_dsp")
				# set a usable list of settings for each monitor
				# 'monitor vars;monitor name;primary;resolution'
				dsp_vars+=("$_dsp;dsp_res_$n;$_prm;$_def")
				n=$[ $n+1 ]
			done
			IFS=$ifs
	
			# set resolutions list in a script manageable lists
			d=0
			# give a list of all resolution per monitor
			for dsp1 in ${connect_[@]}; do
				query=$(xrandr -q| sed -n  "/$dsp1/,/\(\w*[A-Z]\{2,4\}\)/p"| sed -n "/\(\w*[A-Z]\{2,4\}\)/d;p"|awk '{print $1}')
				# convert result to a YAD manageable list
				query=$(printf "$query"| tr '\n' ',')
				dsp_res_+=("dsp_res_$d=$query")
				dsp_res_list+=("$query")
				d=$[ $d+1 ]
			done
			}
	fn_xrandr_config(){
		echo -e "$g_notif >>>> start fn_xrandr_config ####\n$e_notif"
		unset basic_sets track_list
		# create the  data to display in the yad tab
		display_field_set(){
			echo -e "$g_notif >>>> display_field_set $e_notif"
#			X=0; x=1; l=6
			monitor_filter=1
			for x_var in ${dsp_vars[@]}; do
				m_name=$(printf "$x_var"| cut -d';' -f1)
				m_res_list=$(printf "$x_var"| cut -d';' -f2)
				m_prim=$(printf "$x_var"| cut -d';' -f3)
				m_c_res=$(printf "$x_var"| cut -d';' -f4)
#				reso_list=${dsp_res_list[$X]}
				reso_list=${dsp_res_list[@]}
				monitor=$m_name
				if [ $m_prim -gt 0 ]; then
					field_msg0="$nf $m_name (primary)$end"
				else
					field_msg0="$nf $m_name$end"
				fi
				# this function can detect all attached displays, but the actual script can't manage
				# multidisplay at this state. Then, the below conditional filter is added to only
				# manage one display, the primary.
				field_msg1="$nf Choose app resolution$end"
				field_line="$bck_mode,$reso_list;bck_mode;;$field_msg0;CB;;$monitor
$set_mode,$reso_list;set_mode;;$field_msg1;CB;;$monitor"
			done			
		}
		get_pointer_list(){
			echo -e "$g_notif >>>> get_pointer_list$e_notif"
			xinput_list=$(xinput list | grep "pointer"|grep -v "master\|XTEST"| \
			perl -pe "s|^.* ([A-Z].*[a-z]) (\w*[A-Z]+.*id=[0-9]*)+.*$|\1 \2|;s|([ ]*)\t|;|p")
			
			mouse_list=$(printf "${xinput_list[@]}"|cut -d';' -f1|tr '\n' ','|sed -n "s/,$//p")
		}
		# define the most as possible desktop enviroment name, then check if they are in bin three.
		unset dsk_unite
		desktop_prelist="cinnamon,cinnamon2d,compiz,gnome-shell,kde,lxde,marco,mate,openbox,xfce"
		desktop_prelist=( $(echo "$desktop_prelist"| tr ',' ' ') )
		for dsk_ui in ${desktop_prelist[@]}; do
			if [ $dsk_ui == 'mate' ]; then dsk_chk='marco'; else dsk_chk=$dsk_ui; fi
			if [ $(find /usr/{bin,local/bin} -name $dsk_chk| grep -c .) -gt 0 ]; then
				dsk_unite+=("$dsk_ui")
			fi
		done
		desktop_list=$(echo "${dsk_unite[*]}"| tr ' ' ',' )

		# first establish lists for seeked values
		track_list=('auto_set' 'set_desktop_env' 'mouse_set')
		input_vars=('set_output' 'set_mode' 'bck_mode' \
		'default_desktop' 'secondary_desktop' 'mouse_dev' 'set_buttons')
		
		# get previous config if any, but take care of unexistant modules in the file
		_inputs=( "${track_list[@]}" "${input_vars[@]}" )
		for _vars in ${_inputs[@]}; do
			eval _listed='$'$_vars
			if [[ $_listed != '' && ! $_listed =~ ^\w*unset|^0 ]]; then
				case $_vars in
					'auto_set')
						echo -e "$g_notif >>>> get xrd conf$e_notif"
						set_output=$(printf "$set_xrandr"| cut -d' ' -f3)
						set_mode=$(printf "$set_xrandr"| cut -d' ' -f5)
						bck_mode=$(printf "$bck_xrandr"| cut -d' ' -f5)
					;;
					'mouse_set')
						echo -e "$g_notif >>>> get mouse conf$e_notif"
						set_dev_id=$(printf "$mouse_btn"| cut -d' ' -f3)
						set_buttons=$(printf "$mouse_btn"| sed -n "s|^.*$set_dev_id \([0-9].*\)$|\1|p")
					;;
					'bck_mode') dsp_res_list+=(',unset') ;;
					'default_desktop') desktop_list="$desktop_list,unset";;
					'mouse_dev'|'set_buttons') v_unset=',unset' ;;
					*) local $_vars=$_listed ;;
				esac
			else
				case $_vars in
					'auto_set'|'set_desktop_env'|'mouse_set') local $_vars=0 ;;
					*) local $_vars='unset' ;;
				esac
				echo 'beeep'
			fi
		done

#		if [[ $(printf "${input_list[0]}"| grep -c .) -gt 0 ]]; then export ${input_list[@]}; fi

		# add xrandr field to basic_sets list
		display_field_set
		# get mouse list form xinput
		get_pointer_list
		# window messages
		w_text="$bf Configure XRandr Wine app resolution$end\\n$vb\\Special fullscreen mode issue: Change the default desktop resolution.$end"
		w_xrandr_tip="$vb\\In some cases, older game could occur issues when set in fullscreen, the options below allow to set the resolution before the start and then back to default when stop. (also useful for Optimus display behaviour).$end"
#		w_text="$bf Configure XRandr Wine app resolution$end"
		w_xrandr_tip0="$vb\\Desktop main monitor resolution is currently set to$end $nf$current_res$end"
		w_xrandr_def_dsp="$vb\\Select the output to switch to and resolution to switch back$end"
		w_xrandr_tip1="$nf Note:$end Configure connected display only. Primary doesn't necessary mean current connected monitor."
	
		w_xrandr_res_to="Choose app resolution"
		w_xrandr_res_bk="Choose the resolution to swith back"
		w_xrandr_tip2="$bf Compositing$end"
		w_xrandr_tip3="$vb\\If your desktop manager slow down graphic performance, you can try to replace the default one by a lighter.$end"
		w_xrandr_tip6="$nf Note:$end In cinnamon, desactivate compositing in fullscreen mode in System Settings menu: Preferences > General"
		w_xrandr_compo1="$nf Select the default manager$end"
		w_xrandr_compo2="$nf Select the replacement manager\t$end"
		w_xrandr_tip4="$bf\\Mouse buttons setting$end"
		w_xrandr_tip5="$vb\\If you have change the mouse button placement, replacement window manager can reverse your set. This option allow you to preserve it$end"
		w_xrandr_mouse="$nf Select the mouse device$end"
		w_xrandr_buttons="$nf Select the button preset$end"
		
		basic_sets="'';;;;LBL;;
'';;;$w_xrandr_tip;LBL;;
'';;;;LBL;;
'';;;$w_xrandr_tip0;LBL;;
'';;;$w_xrandr_def_dsp;LBL;;
'';;;$w_xrandr_tip1;LBL;;
${field_line[@]}
'';;;;LBL;;
'';;;$w_xrandr_tip3;LBL;;
'';;;$w_xrandr_tip6;LBL;;
$default_desktop,$desktop_list;default_desktop;;$w_xrandr_compo1;CBE;;
$secondary_desktop,$desktop_list;secondary_desktop;;$w_xrandr_compo2;CBE;;
'';;;;LBL;;
'';;;$w_xrandr_tip4;LBL;;
'';;;$w_xrandr_tip5;LBL;;
$mouse_dev,$mouse_list$v_unset;mouse_dev;;$w_xrandr_mouse;CB;;
$set_buttons,1 2 3,3 2 1$v_unset;set_buttons;;$w_xrandr_buttons;CB;;"
		echo -e "$g_notif\n>>>> end fn_xrandr_config ####\n$e_notif"
		
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# window style and function
		
	}
	fn_optimus_config(){
		echo -e "$g_notif\n>>>> start fn_optimus_config ####\n$e_notif"
		unset basic_sets track_list
		# window messages
		w_text="$bf Optimus special options and sets$end\\n$vb\\If you own a Optimus Laptop, you can set here the dedicated commands and options.$end"
		w_text_tip="$vb\\If you own a Optimus Laptop, you can set here the dedicated commands and options usualy use by Linux Optimus manager.$end"
		w_opti_warn="$nf\\Note:$end For games, we strongly recommand to use Nvidia-Prime instead of Bumblebee. there's a few tools on the Web, Google them!"	
		w_opti_tip0="$vb\\Choice for Bumblebee can be primus or virtualgl as virtualizer.$end"
		w_opti_tip1="$nf\\Note: unset will use Bumblebee default virtualizer$end"
		w_opti_tip2="$vb\\Primus SYNC environment option is sometime useful in bad frame render$end"
		w_opti_tip3="$vb\\Vertical Sync to vblank is usualy not use because of a virtualizer issue$end"
		w_opti_starter="$nf Select the Optimus launcher\t\t\t$end"
		w_opti_opts="Set the Bumblebee (b) option"
		w_opti_accel="$nf Set the virtualizer$end"
		w_opti_sync="Set the primus SYNC option (optional)"
		w_opti_vblank="Set Vertical Sync (optional)"
		
		track_list=('opti_starter' 'opti_accel' 'opti_SYNC' 'opti_VBLK')
		for trk_set in ${track_list[@]}; do
			eval trk_field='$'$trk_set
			if [[ $trk_set =~ opti_starter|opti_accel ]]; then
				if [[ $trk_field == '' ]]; then
					local $trk_set='unset'
					local d_set_$trk_set=''
				else
					local d_set_$trk_set=',unset'
				fi
			fi
		done
		# var list sets
		basic_sets="'';;;;LBL;;
$opti_starter,optirun,primusrun$d_set_opti_starter;opti_starter;;$w_opti_starter;CB;;
'';;;$w_opti_tip0;LBL;;
'';;;$w_opti_tip1;LBL;;
$opti_accel,virtualgl,primus$d_set_opti_accel;opti_accel;;$w_opti_accel;CB;;
'';;;$w_opti_tip2;LBL;;
$opti_SYNC;opti_SYNC;;$w_opti_sync;CHK;;
'';;;$w_opti_tip3;LBL;;
$opti_VBLK;opti_VBLK;;$w_opti_vblank;CHK;;
'';;;;LBL;;
'';;;$w_opti_warn;LBL;;"
		echo -e "$g_notif\n>>>> end fn_optimus_config $e_notif"
		
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# window style and function
		
	}
	control_line(){
		#  | gzip -cd| sed -E -n "s/^.*(wine-staging[0-9]+-([0-9].*)\.x86_64.*)\".*$/\1 \2/p"
		## connection test and PoL la bianry version per arch
		unset pol_list
		line=$(nc -z 8.8.8.8 53)
		line=$?
		
		pol_list=('32,x86' '64,amd64')
		if [ $line = 0 ]; then
			ct_msg='On'
		else
			ct_msg='Off'
		fi
		for c in ${pol_list[@]}; do
			arch=$(printf "$c"| cut -d',' -f1)
			adir=$(printf "$c"| cut -d',' -f2)
			if [ "$ct_msg" == 'On' ]; then
				pol=$(mktemp --tmpdir pol.XXXXXXXX)
				wget -O $pol http://wine.playonlinux.com/binaries/linux-$adir.lst
				pol_x=( pol$arch=$(tac "$pol"| cut -d';' -f2| sed -n '1p' ) )
				rm -f $pol
			else
				pol_x=( pol$arch='no data available' )
			fi
			export $pol_x
		done
		sys_version=$(/usr/bin/wine --version)
		
#		arch_list=('32,x86,i686' '64,amd64,x86_64')
#		if [ $wine_elf = 1 ]; then ftp_elf='amd64'; http_elf='x86_64'; else ftp_elf='x86'; http_elf='i686'; fi
#		file_temp=$(mktemp --tmpdir last.XXXXXXXX)
#		
#		dl_address[0]="http://wine.playonlinux.com/binaries/linux-$ftp_elf.lst"
#		dl_address[1]="https://dl.winehq.org/wine-builds/fedora/"
#		loc=0
#		until [ $loc -eq 1 ]; do
#			bin_class=$loc
#			dl_address=$dl_address[$loc]
#			download_list
#		done
#		
#		
#		
#		
#		if [ $line = 0 ]; then
#			ct_msg='On'
#		else
#			ct_msg='Off'
#		fi
#		for src in 
#		for c in ${arch_list[@]}; do
#			arch=$(printf "$c"| cut -d',' -f1)
#			adir=$(printf "$c"| cut -d',' -f2)
#			if [ "$ct_msg" == 'On' ]; then
#				pol=$(mktemp --tmpdir pol.XXXXXXXX)
#				wget -O $pol http://wine.playonlinux.com/binaries/linux-$adir.lst
#				pol_x=( pol$arch=$(tac "$pol"| cut -d';' -f2| sed -n '1p' ) )
#				rm -f $pol
#			else
#				pol_x=( pol$arch='no data available' )
#			fi
#			export $pol_x
#		done
		
		
	}
	key=$RANDOM
	sleep 1
	kill $YAD_PID
	messages
	control_line
	unset active_values active_export inactive_values inactive_export cl
	## create 2 temp file for all conf section edit.
	TEMP_conf=$(mktemp --tmpdir tmp1.XXXXXXXX)
	TEMP_edit=$(mktemp --tmpdir tmp2.XXXXXXXX)
	## create a winetricks dlls list temp file.
#	TEMP_trks=$(mktemp --tmpdir trk0.XXXXXXXX)
	if [ -s $HOME/.config/user-dirs.dirs ]; then
		. $HOME/.config/user-dirs.dirs
	fi
	if [ $from_config = 1 ]; then
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		# all active values extraction with the 'export'
		active_values+=(
		$(cat $config_file | sed -n "s|^export||;s|^\(\w*[a-z].*\)=\(.*\).*$|\1=\2|p"|sed -n "s|['\|\"]||g;p")
		)
		# 'export'ed values extraction
		active_export+=( $(
		_export=$(cat $config_file | sed -n "s|^\(\w*[a-z].*\)=\(.*\).*$|\1=\2|;s|^export ||p")
			for _rewrite in '__GL_THREADED_OPTIMIZATIONS' '__GL_YIELD'; do
				case $_rewrite in
					'__GL_THREADED_OPTIMIZATIONS') _export=$(echo "$_export"| \
					sed -En "s/^(LD_PRELOAD=.*)(__GL_THREADED_OPTIMIZATIONS=[0-9])/\2/i;p")
					;;
					'__GL_YIELD') _export=$(echo "$_export"| \
					sed -En "s/^(__GL_YIELD)=([\"]?)(\w*)([\"]?)$/\1=\3/i;p")
					;;
				esac 
			done
			echo "$_export") )
		# inactives values extraction
		inactive_values+=(
		$(cat $config_file | sed -n "s|^#\(\w*[a-z].*\)=\(.*\).*$|\1=unset|p"| grep -v "export")
		)
		# inactives 'export' values extraction
		inactive_export+=(
		$(cat $config_file | sed -n "s|^#\(\w*[a-z].*\) \(.*\)=\(.*\).*$|\2=unset|p")
		)
		if [ ${#active_values} -gt 0 ]; then local "${active_values[@]}"; fi
		if [ ${#active_export} -gt 0 ]; then local "${active_export[@]}"; fi
		if [ ${#inactive_values} -gt 0 ]; then local "${inactive_values[@]}"; fi
		if [ ${#inactive_export} -gt 0 ]; then local "${inactive_export[@]}"; fi
		IFS=$ifs
		fn_wine_elf_query
		cat $config_file > $TEMP_conf
	fi
	
	section_list=('_wine' '_wbin' '_install' '_tricks' '_reged' '_nvidia_1' '_nvidia_2' '_xrandr' '_optimus' '_extended')
	for s_var in ${section_list[@]}; do
		eval f_var='$'$s_var
		if [[ $f_var == '' ]]; then
			local $s_var=0
		fi
	done
	
	if [ $(printf "${cl[*]}"| grep -c .) -gt 0 ]; then local "${cl[@]}"; fi
	get_xrandr_list
	if [ $code = 0 ]; then
		if ! [ -s $HOME/.winestarter/default-wine ]; then touch $HOME/.winestarter/default-wine; fi
		if [[ $wine_bin != '' ]]; then
#		if [[ $wine_bin == '' ]]; then
			sys_version=$($wine_bin --version)
			if [ $b_set = 1 ]; then
				fn_basics_config
			else
				fn_create_prefix			
			fi
		else
			fn_binary_env
		fi
	else
		fn_nvidia_config
	fi
	
}
########### MAIN ###########
export wine_bin=$(find /usr/{bin,local/bin} -name wine)
export w_tricks_bin=$(find /usr/{bin,local/bin} -name winetricks)
export yad_bin=$(find /usr/{bin,local/bin} -name yad)
export zen_bin=$(find /usr/{bin,local/bin} -name zenity)
export conv_bin=$(find /usr/{bin,local/bin} -name convert)
export icot_bin=$(find /usr/{bin,local/bin} -name icotool)
export wres_bin=$(find /usr/{bin,local/bin} -name wrestool)
export lpci_bin=$(find /{bin,sbin} /usr/{bin,sbin} -name lspci)
export rpm_bin=$(find /usr/{bin,local/bin} -name rpm2cpio)
# PlayOnLinux packages download window
# select_win_bin(){ colors ; icons_set ; select_wine_bin; }
edit_reg_bin(){ colors ; icons_set ; edit_regfile; }
edit_regfile(){
#	reg_move=$(mktemp --tmpdir reg2.XXXXXXXX)
	reg_edit=$(mktemp --tmpdir reg3.XXXXXXXX)
#	reg_temp=$(mktemp --tmpdir reg4.XXXXXXXX)
	reg_display=$(cat $reg_file| perl -pe "s|\\\|\\\\\\\|g;p"| tr '*' '\n')
	
	w_text="$bf\\Register manual edit$end\\n \
$nf\\All custom maunal changes in the text area will be merge with others presets.$end"
	w_com0="$vb Custom register (manual edit).$end"
	w_com1="$rb\\Warning:$end$vb Remove all custom (set by yourself) or empty lines$end"

	reg_popup=$(
	$yad_bin --width=400 --title "$w_title" --image="$img_wine_desk_ui" --borders=15 \
	--window-icon="$img_wine_desk_ui" --form --text="$w_text" --separator=" " --item-separator="#" \
	--field="$w_com1":LBL '' --field="$w_com0":TXT "$reg_display")
	
	if [ $? = 0 ]; then
		printf "$reg_popup"| tr '\n' '*' > $reg_edit
		export reg_edit=$reg_edit
	else
		exit 0
	fi
	
}
edit_wine_options(){
	colors ; icons_set
	# form: "$_msc_short;$_msc_arg;$_msc_var;0"
	## make a readable list
	options_list=( $(cat "$option_log") )
	for opt in ${options_list[@]}; do
		## cut the sets in file to make variables
		_active=$(printf "$opt"| cut -d";" -f4)
		_option=$(printf "$opt"| cut -d";" -f2)
		## define if variables are already active in resources conf file
		if [ -s $option_conf ]; then
			if [ $(cat "$option_conf"| egrep -c "$_option") -gt 0 ]; then
				_definition="$(cat "$option_conf"| egrep "$_option"| cut -d";" -f2)"
				_active=1
			else
				_definition="enter a short description"
			fi
		fi
		## define the default tip message
		# _help_tip=""
		## make 'active' conf usable by yad
		if [ $_active -gt 0 ]; then
			col+=("TRUE" "$_option" "$_definition")
		else
			col+=("FALSE" "$_option" "$_definition")
		fi
	done
	## set tip and help texts
	conf_txt="$bf\\Add options to default list$end\\n$vb\\Choose manually added options to default options menu list. They will be kept for all future bottles.$end\\n$rb\\WARNING:$end Added options can be only remove from the original bottle or by manual edit into default options list file."
	## create the yad window with the properly setted variables 
	change_opts=$($yad_bin --width=500 --height=400 --title= --image="$img_wine_opts" --borders=15 \
	--window-icon="$img_desktop" --list --checklist --text="$conf_txt" --editable --separator=";" \
	--print-all --column="Active" --column="Option" --column="Descriptions" \
	"${col[@]}")
	## second part: load pined options into opntions.list
	## form: TRUE;option;description; > option;description
	## prepare script to read yad output lines
	ifs=$IFS
	IFS=$(echo -en "\n\b")
	## analyse yad output and add or remove in options conf file
	for _chg_opt in ${change_opts[@]}; do
		## cut the sets in file to make variables
		_chg_active=$(printf "$_chg_opt"| cut -d";" -f1)
		_chg_option=$(printf "$_chg_opt"| cut -d";" -f2)
		_chg_definition=$(printf "$_chg_opt"| cut -d";" -f3)
		## probe if variables active or inactive, then add or remove them if any
		if [[ $_chg_active == TRUE ]]; then
			## add option to default winestarter wine option conf
			_act_num=1
			if [ $(cat $option_conf| grep -c "$_chg_option") -eq 0 ]; then
				sed -E -ni "s/(^misc.*$)/$_chg_option;$_chg_definition\n\1/i;p" $option_conf
			fi
		else
			_act_num=0
			## if unset, remove custom wine option from wine options conf 
			if [ $(cat $option_conf| grep -c "$_chg_option") -gt 0 ]; then
				modified_conf=$(cat $option_conf| grep -v "$_chg_option")
				printf "$modified_conf" > $option_conf
			fi
		fi
		sed -E -ni "s/(^.*;$_chg_option.*);([0-9])/\1;$_act_num/i;p" $option_log
	done
	## restore IFS and exit to previous window
	IFS=$ifs
}
select_wine_bin(){
	colors ; icons_set
	bin_class=0
	if [ $wine_elf = 1 ]; then ftp_elf='amd64'; else ftp_elf='x86'; fi
	dl_address="http://wine.playonlinux.com/binaries/linux-$ftp_elf.lst"
	site='PlayOnLinux'
	window_ico="$img_desktop"
	window_img="$img_dl_pol"
	select_wine_binary
}
select_wine_dis(){
	colors ; icons_set
	bin_class=1
	if [ $wine_elf = 1 ]; then http_elf='x86_64'; else http_elf='i686'; fi
#	dl_address="https://dl.winehq.org/wine-builds/fedora/25/$http_elf/"
	dl_address="https://dl.winehq.org/wine-builds/fedora/"
	site='WineHQ'
	window_ico="$img_desktop"
	window_img="$img_dl_whq"
	select_wine_binary
}
download_list(){
	wget -O $file_temp $dl_address
	if [ $bin_class -gt 0 ]; then
	## WineHQ give multiple repos for fedora project. To get all availables, we take in all fedora
	## version and put them in a single var.
		os_version=$(tac $file_temp | egrep -o "indexcolname.*href=\"[0-9]{2}\/\""| \
		sed -En "s/^.*([0-9]{2}).*$/\1/p")
		for os_v in ${os_version[@]}; do
			wget -O $file_temp.[$os_v] $dl_address/$os_v/$http_elf/
			dl_bin_list[$os_v]=$(tac $file_temp.[$os_v]| egrep "wine-staging$elf-[0-9]+"| \
			sed -En "s/^.*$elf-([0-9]\.[0-9]*)-([0-9]).$http_elf.*$/\1-\2-staging,$os_v/p")
		## merge only if Wine version is different.
			if [ $os_v_p ]; then
				if [ $os_v -ne $os_v_p ]; then
					new_output=$(echo "${dl_bin_list[$os_v]}"|cut -d',' -f1)
					prev_output=$(echo "${dl_bin_list[$os_v_p]}"|cut -d',' -f1)
					_diff=$(echo "$new_output"| grep -vc "$prev_output")
					if [ $_diff -gt 0 ]; then
						_added=$(echo "${dl_bin_list[$os_v]}"| grep -v "$prev_output")
						dl_bin_list[$os_v]=$(echo -e "${dl_bin_list[$os_v_p]}\n$_added")
						dl_bin_list=${dl_bin_list[$os_v]}
	#						echo "${dl_bin_list[$os_v]}" > $list_temp
					fi
					os_v_p=$os_v
				fi
			else
				os_v_p=$os_v
			fi
		done
	else
		wget -O $file_temp $dl_address
		dl_bin_list=( "$(tac "$file_temp"| cut -d';' -f2)" )
	fi
	if [ ${#local_bin_list[@]} -gt 0 ]; then
		for existing in ${local_bin_list[@]}; do
			if [ $(printf "$dl_bin_list"| grep -c "$existing") -gt 0 ]; then
				dl_bin_list=$(echo "$dl_bin_list"| sed -En "s/^($existing)(.*$)/\1*\2/g;p")
			fi
		done
	fi
	echo "$dl_bin_list" > $file_temp.[list]
}
select_wine_binary(){
	unset dl_bin_list local_bin_list wine_bin_list
	wine_bin_temp=$(mktemp --tmpdir w_binary.XXXXXXXX)
	if [ $wine_elf = 1 ]; then ftp_elf='amd64'; elf='64'; else ftp_elf='x86'; elf=''; fi
	# ls already insbtalled packages if any
#	if [ $default_bin_dir ]; then 
	if [ -d $wine_path ]&&[ "$wine_path" != "$HOME" ]; then	
			local_bin_list=( $(ls -1x $wine_path/$ftp_elf) )
	fi
	if [ -s /usr/bin/wget ]; then
		# First, download wine packages list. Because Fedora repository is more simple than debian one,
		# list dosnload is done from there (i686 repo)
		file_temp=$(mktemp --tmpdir ftp.XXXXXXXX)
		p_text="$vb\Retrieving $site server information$end"
		download_list | $yad_bin --width=200 --title "Please wait..." --text-align=center \
		--no-buttons --on-top --window-icon=$img_wine_ui --progress --pulsate --auto-close \
		--text="$p_text" --progress-text=""
		
#		wine_bin_list=$(cat $list_temp)
#		wine_bin_list=( $(echo "$dl_bin_list"| tr '\n' ','|sed -n "s/,$//p") )
		wine_bin_list=( $(cat $file_temp.[list]| cut -d',' -f1| tr '\n' ','|sed -n "s/,$//p") )
		wine_bin=$($yad_bin --width=300 --title "$w_title" --image="$window_img" --borders=15 \
		--window-icon="$window_ico" --form --text="$w_text" --separator=" " --item-separator="," \
		--field="$vb Select $ftp_elf package from $site$end":CB "$wine_bin_list")
		
		if [ $? = 0	 ]; then
			if [ $wine_bin != '' ]; then
				wine_bin=$(printf	"$wine_bin"| sed -En "s/[*]? $//g;p")
				if [ $bin_class -gt 0 ]; then
					dist_dl_ver=$(cat $file_temp.[list]| sed -En "s/^$wine_bin,(.*)$/\1/p")
				else
					dist_dl_ver=0
				fi
#				printf "$wine_bin;$bin_class"| sed -n "s/ //g;p" > /tmp/w_bin_tmp
				printf "$wine_bin;$bin_class;$dist_dl_ver" > $wine_bin_temp
			fi
		else
			rm -f $file_temp $list_temp
			exit 0
		fi
		rm -f $file_temp $list_temp
	fi
}
### main ui buttons functions
## manage configs and bottles
#delete_conf(){}
## manage ui font colors
change_fonts_colors(){
	unset font_color color_fonts prev_colors prev_fonts
	sleep 1
	kill $YAD_PID
	w_text="$bf\\Basic font colors and style$end$vb\\n\
Change UI fonts colors and kind at will, but keep in mind the sens of each of them: main, warning, unavialable.$end"
	w_tip="$rb\\WARNING$end$vn: Don't select fonts with more than 2 words if it's not a \"regular\" or \"italic\", it won't be displayed correctly.\nYou can also extend window width up to 100px if the horizontal scrollbar still appears in some tabs.$end"
	font_color=$($yad_bin --width=480 --height=300 --title "$w_title" --image="$img_wine_desktop" \
			--window-icon=$img_wine_desk_ui --text "$w_text" --form --separator="|" --item-separator="," \
			--borders=15 --field="":LBL '' \
			--field="$vb Main messages color\t\t$end":CLR "$main" \
			--field="$vb Warning messages color$end":CLR "$warn" \
			--field="$vb Unavialable messages color$end":CLR "$freeze" \
			--field="$vb Normal font type$end":FN "$font0 $size0" \
			--field="$vb Titles font type$end":FN "$font1 $size1" \
			--field="$vb Add more width to windoow display$end":SCL "$scale,0..100" \
			--field="$w_tip":LBL '')
	if [ $? = 1 ]; then bash $bash_opt $base_script; exit 0; fi
	if [ $? = 0 ]; then
		prev_colors=$(printf "$font_color"| sed -n "s/^|//;s/\(^.*\)||/\1/p" ) #
		
		ifs=$IFS
		IFS='|'
		for i in ${prev_colors[@]} ; do
			color_fonts+=("$i")
			echo "$i"
		done
		echo "${color_fonts[@]}"
		IFS=$ifs
		C=0 ; D=0
		## main color/font vars
		fields=( 'main' 'warning' 'freeze' 'norm' 'big' 'scale' )
		## stick collected new vars to script vars 
		for colr in ${fields[@]}; do
			previous=${color_fonts[$C]}
			if [[ $colr == norm || $colr == big ]]; then
				## divide font block name into font name and size
				echo "$D"
				size=$(printf "$previous"| grep -o "[0-9]*")
				font=$(printf "$previous"| sed -n "s/\(^.*\) [0-9]*/\1/p")
				new_fields+=("font$D;$font")
				new_fields+=("size$D;$size")
				D=$[ $D+1 ]
			else
				new_fields+=("$colr;$previous")
			fi
			C=$[ $C+1 ]
		done
		for f in "${new_fields[@]}"; do
			cl_var=$(printf "$f"| cut -d';' -f1)
			cl_val=$(printf "$f"| cut -d';' -f2)
			perl -ni -pe "s|(^$cl_var=)'.*'$|\1'$cl_val'|i" $HOME/.winestarter/color.conf
		done
		bash $bash_opt $base_script
	fi
	exit 0
}
## get configured bottles list mandatory for other modules use.
colors ; icons_set
list_bottles(){
	if [ -d $HOME/.winestarter/configs ]; then
		if [ $(ls -1 $HOME/.winestarter/configs/| egrep -c "*[.conf]$") -gt 0 ]; then
			config_list=$(ls -1 $HOME/.winestarter/configs/| egrep "*[.conf]$")
			for config in ${config_list[@]}; do
				b_conf=$config
				b_name=$(cat $HOME/.winestarter/configs/$config| grep -w "bottle_prefix="|sed -n "s/^.*=\"\.//;s/\"//p" )
				bottle_list+=("$b_name")
				bottle+=("$b_name;$b_conf")
			done
			bottle_list=$(printf "${bottle_list[*]}"|sed -n "s/ /#/g;p")
		else
			bottle_list="none"
		fi
	fi
}
## edit or create a new desktop file entry.
edit_desktop(){
	## clear all lists
	unset desk_var_list def_list icon_id icon_def
	sleep 1
	## kill previous yad window
	kill $YAD_PID
	## load the config file
	. $config_file
	## define th default winestarter path
	_path_set=$HOME/.winestarter
	_img_set=$_path_set/png
	emblem_png=$_path_set/emblems/wine_emblem.png
	## define the basic vars to create a desktop file
	desk_var_list=('user_prefix' 'bottle_prefix' 'game_dir' 'game_exe' 'wine_elf')
	for d_var in ${desk_var_list[@]}; do
		eval _conf_set='$'$d_var
		appli_dir_set+=("$d_var=$_conf_set")
	done
	## apply them as vars to be sued by the script
	local "${appli_dir_set[@]}"
	## extract and create thumbnails of the app icons in pngs
	ifs=$IFS
	IFS=$(echo -en "\n\b")
	# set the exe path and bin
	if [[ $game_exe =~ ^.*\.(exe|EXE)$ ]]; then
		if [ -d $user_prefix/$bottle_prefix/drive_c/$game_dir ]; then
			exe_path="$user_prefix/$bottle_prefix/drive_c/$game_dir/$game_exe"
		else
			if [ $wine_elf = 1 ]; then elf_ext=' (x86)'; else elf_ext=''; fi
			exe_path="$user_prefix/$bottle_prefix/drive_c/Program Files$elf_ext/$game_dir/$game_exe"
		fi
		# set the icon type to extract
		ico_type=14
		# extract the icon
		$wres_bin -x -t $ico_type -o $_path_set/icons $exe_path
		exe_name=$(printf "$exe_path"| sed -n "s|^.*/||g;p")
		default_name=$(printf "$exe_name"| sed -n "s/.exe$//p")
	else
		exe_path='unknown'
		exe_name='unknown'
		default_name='unknown'
	fi
	
	config_name=$(printf "$config_file"|sed -n "s|^.*/||p")
	IFS=$ifs
	# predefine category set default value. Will be overwrited if desktop file entry exist
	cat_set='unset'
	## control if there is an existing desktop file
	# define the main Desktop directory
	. $HOME/.config/user-dirs.dirs
	desktop_vars=(
		"1,Name,5"
		"1,Comment,6"
		"0,Exec,winestarter $config_name"
		"2,Icon,2"
		"0,StartupWMClass,$exe_name"
		"1,dsk_menu,10"
		"1,Categories,7"
		"1,emblem,12")
	# extract the png from the icon in multi definition format
	def_list=('256' '128' '64' '48')
	if [[ $exe_name != unknown ]]; then
		for _def in ${def_list[@]}; do
			# look for index for the asked definition
			idx=$($icot_bin -l $_path_set/icons/$exe_name\_$ico_type\_*.ico| \
			grep "\(width=$_def\).*\(bit-depth=32\)"| sed -n "s/^.*--index=\([0-9]\).*$/\1/g;p")
			if [[ $idx > 0 ]]; then
				$icot_bin -x -i $idx -o $_path_set/png $_path_set/icons/$exe_name\_$ico_type\_*.ico
				png_file=$(ls -1 $_path_set/png/$exe_name\_$ico_type*\_$_def\x$_def*.png)
				if [[ -s $png_file ]]; then
				thb_file=$_path_set/png/thumb/$(printf "$png_file"| sed -n "s/^.*\///g;p")
				# create thumbnail for yad UI
				$conv_bin $png_file -scale 48x48 $thb_file
				else
					png_file=$_path_set/png/defaults/warning.png
					thb_file=$_path_set/png/defaults/warning.png
				fi
				# make def field readable
				png_def="$_def"x"$_def"
				icon_id+=("$thb_file")
				icon_id+=("$png_file")
				icon_id+=("$png_def")
				icon_def+=("$png_file,$png_def")
			fi
		done
	
		# extract the desktop file entry variables, if any, and make them usable by the script
		if [ -e $XDG_DESKTOP_DIR/$exe_name.desktop ]; then
			echo -e ">>>>>>>>>>>>>>>>>\n"
			ifs=$IFS
			IFS=$(echo -en "\n\b")
			desktop_data=( $(cat $XDG_DESKTOP_DIR/$exe_name.desktop| egrep -v "^\[.*\]$") )
			for _vars in ${desktop_data[*]}; do
				_var=$(printf "$_vars"| cut -d'=' -f1)
				_val=$(printf "$_vars"| cut -d'=' -f2)
				case $_var in
	#				'Type');;
					'Exec') if [ $_val ]; then default_cmd=$_val; fi;;
					'StartupWMClass') if [ $_val ]; then exe_name=$_val; fi;;
					'Name') if [ $_val ]; then default_name=$_val; fi;;
					'Comment') default_desc=$_val;;
					'Categories') if [ $_val ]; then cat_set=$_val; else cat_set='unset'; fi;;
					'Icon') png_file=$_val;;
				esac
			done
			IFS=$ifs
			## add the desktop icon to the icon list if extracted from the desktop file entry
			# make a thumbnail for yad UI
			# test first if theere is already a corresponding image in path.
			if ! [ -s $_path_set/png/thumb/$exe_name.png ]; then
				thb_file=$_path_set/png/thumb/$(printf "$png_file"| sed -n "s/^.*\///g;p")
				$conv_bin $png_file -scale 48x48 $thb_file
			else
				png_file=$_path_set/png/$exe_name.png
				thb_file=$_path_set/png/thumb/$exe_name.png
			fi
			if ! [[ $png_file ]]; then
				png_file=$_path_set/png/defaults/warning.png
				thb_file=$_path_set/png/defaults/warning.png
			fi
			# get image dimensions
			png_def=$(file $png_file | sed -En "s| ||g;s|^.*,([0-9]*.*)x([0-9]*.*),[0-9].*$|\1x\2|p")
			# add it to the list
			icon_id+=("$thb_file")
			icon_id+=("$png_file")
			icon_id+=("existing desktop file entry,$png_def")
			icon_def+=("$png_file,$png_def")
		fi
	else
		icon_id=("$_path_set/png/defaults/unknown.png" "$_path_set/png/defaults/unknown.png" "no default pg found,48x48")
	fi
	## window messages and tips
	w_text="$bf Create a dedicated desktop file$end \\n \
$vb You can create or modify every main fields of a desktop file$end"
	w_tip0="$vb\Select an icon for you desktop file from the right list$end"
	w_tip1="$vb\Choose or edit a display name, a description and a menu category for the desktop file$end"
	w_tip2="$vb\By default, desktop entry is add to the deskop only $end"
	w_tip3="$vb\Winestarter automatical add a Wine emblem to easely detach its managed softwares. You can remove it by unsetting the check box here.$end"
	w_custom_icon="$vb\\Select a custum icon instead of listed$end"
	## create paned window and send result to associated temp files
	key=$RANDOM
	temp1=$(mktemp --tmpdir tab1.XXXXXXXX)
	temp2=$(mktemp --tmpdir tab2.XXXXXXXX)
	# editable categories list for Category entry combo box
	categories='Games;#Office;#Applications;#Games;#Multimedia;#Video;#Graphics;'
	# select_pan part
#	$yad_bin --width=440 --height=300 --plug=$key --tabnum=1 --form --image=$img_wine_desktop \
	$yad_bin --width=440 --height=300 --plug=$key --tabnum=1 --form \
			--item-separator="#" --borders=5 --field="":LBL '' \
			--field="$w_tip0":LBL '' \
			--field="":LBL '' \
			--field="$w_tip1":LBL '' \
			--field="$vb Name$end": "$default_name" \
			--field="$vb Comment$end": "$default_desc" \
			--field="$vb Category$end":CBE "$cat_set#$categories" \
			--field="":LBL '' \
			--field="$w_tip2":LBL '' \
			--field="Add the dessktop entry to the dedicated type menu":CHK TRUE \
			--field="$w_tip3":LBL '' \
			--field="Add a Wine sticky emblem in top right corner":CHK TRUE \
			--field="$w_custom_icon":LBL '' \
			--field="$vb Custom icon$end":FL "$HOME/" \
			--separator=',' &> $temp1 &
	# icon_pan part
	$yad_bin --width=60 --height=300 --plug=$key --tabnum=2 --borders=5 --list \
			--tooltip-column=3 --hide-column=3 --no-rules-hint --separator=',' \
			--column='icon list':IMG --column='path':HD --column='tip':TIP \
			"${icon_id[@]}" &> $temp2 &
	# main paned window
	w_width=$((520+$scale))
	w_splitter=$((380+$scale))
	$yad_bin --width=$w_width --height=300 --title "$w_title" --window-icon=$img_wine_desk_ui \
	--borders=15 --text "$w_text" --paned --key=$key --orient=hor --splitter=$w_splitter
	if [ $? = 1 ]; then exit 0; fi
	## extract setted variable from temp files
	# create a new temp file if creating a new desktop file
	temp3=$(mktemp --tmpdir desktop.XXXXXXXX)
	# order temp file by variable raws
	tmp_files=("0," "1,$temp1" "2,$temp2")
	rk=0
	for tmp in ${tmp_files[@]}; do
		tp_rk=$(printf "$tmp"| cut -d',' -f1)
		tp_fl=$(printf "$tmp"| cut -d',' -f2)
		if [ $rk -eq $tp_rk ]; then
			#make sure data come from temp file or not
			if [[ $tp_fl != '' ]]&&[ -e $tp_fl ]; then
				tmp_data=$(cat $tp_fl)
			fi
			for t_vars in "${desktop_vars[@]}"; do
				tmp_rank=$(printf "$t_vars"| cut -d',' -f1)
				dsk_var=$(printf "$t_vars"| cut -d',' -f2)
				dsk_rank=$(printf "$t_vars"| cut -d',' -f3)
				#control again if data come from temp file or not, then apply correct filter
				if [ $tmp_rank = $tp_rk ]&&[[ $dsk_rank != '' ]]; then
					if [ $tp_fl	!= '' ]&&[ -e $tp_fl ]; then
						dsk_field=$(printf "$tmp_data"|cut -d',' -f$dsk_rank)
					else
						dsk_field=$dsk_rank
					fi
					desktop_field+=("$dsk_var=$dsk_field")
				fi
			done
			rk=$[ $rk+1 ]
		fi
	done
	convert_icon=0
	# take emblem png definition from file
	emblem_def=$(file $emblem_png| perl -pe "s| ||g;s|^.*,([0-9]*.*)x([0-9]*.*),[0-9].*$|\1x\2|p")
	## parse now data to desktop entry
	for keys in "${desktop_field[@]}"; do
		fld_var=$(printf "$keys"| cut -d'=' -f1)
		fld_entry=$(printf "$keys"| cut -d'=' -f2)
		# if emblem overlay is selected, check vlaue first before telling to script to create 
		# the overlay at the next loop.
		if [ "$fld_entry" == TRUE ]; then
			if [ "$fld_var" == emblem ]; then convert_icon=1; else convert_icon=0; fi
			if [ "$fld_var" == dsk_menu ]; then menu_entry=1; else menu_entry=0; fi
		fi
		# next loop create the overlay if set.
		if [[ "$fld_var" == Icon && $convert_icon = 1 ]]; then
			for l_png in ${icon_def[@]}; do
				png=$(printf "$l_png"| cut -d',' -f1)
				def=$(printf "$l_png"| cut -d',' -f2)
				if [ $png == $fld_entry ]; then
					if [ $(printf "$fld_entry"| grep -c "$emblem_def") = 0 ]; then
						scale="-scale $def"
					fi
				fi
			done
			$conv_bin $fld_entry $emblem_png $scale -composite $_img_set/$exe_name.png
			fld_entry=$_img_set/$exe_name.png
			keys="$fld_var=$fld_entry"
		fi
		# control if this is an edit from existing file and then apply correct filter
		if [ -a $XDG_DESKTOP_DIR/$exe_name.desktop ]; then
			perl -ni -pe "s|^($fld_var=)(.*)$|\1$fld_entry|i" \
			$XDG_DESKTOP_DIR/$exe_name.desktop
			if [ $menu_entry = 1 ]&&[ $HOME/.local/share/applications/$exe_name.desktop ]; then
				perl -ni -pe "s|^($fld_var=)(.*)$|\1$fld_entry|i" \
				$HOME/.local/share/applications/$exe_name.desktop
			fi
		else
			if ! [[ $fld_var == emblem || $fld_var == dsk_menu ]]; then printf "$keys\n" >> $temp3; fi
		fi
	done
	# for complete new desktop file entry creation add first line headers in first place. 
	if [ ! -f $XDG_DESKTOP_DIR/$exe_name.desktop ]; then
		printf "[Desktop Entry]\nEncoding=UTF-8\nType=Application\n" > $XDG_DESKTOP_DIR/$exe_name.desktop
		cat $temp3 >> $XDG_DESKTOP_DIR/$exe_name.desktop
		chmod 755 $XDG_DESKTOP_DIR/$exe_name.desktop
		if [ $menu_entry = 1 ]; then
			touch $HOME/.local/share/applications/$exe_name.desktop
			cat $XDG_DESKTOP_DIR/$exe_name.desktop > $HOME/.local/share/applications/$exe_name.desktop
			chmod 755 $HOME/.local/share/applications/$exe_name.desktop
		fi
	fi
	# all done, bye bye.
	exit 0
}
edit_bottle(){
	unset more_value
	sleep 1
	kill $YAD_PID
	list_bottles
	if [ $desktop_file = 1 ]; then
		if [ $rstart = 1 ]; then
		w_text="$bf Restart function system$end$vb\\n \
You can here restart Winecfg or Winetricks at next Winestarter launch. This feature could be really useful after a Wine update or just to control Winecfg state$end"
		win_icon=$img_wine_restart
		edit_win=$($yad_bin --width=420 --title "$w_title" --image=$img_wine_reload --borders=15 \
			--window-icon=$img_desktop --center --separator=';' --form --item-separator="#" \
			--align=left --text "$w_text" --field="":LBL '' \
			--field="$vb Select a Wine bottle$end":CB "$bottle_list" \
			--field="Relaunch Winecfg UI":CHK 'FALSE' \
			--field="Restart Winetricks process":CHK 'FALSE')
		else
		w_text="$bf Wine bottle desktop file edition$end$vb\\n \
Select the bottle you would like for a desktop file$end"
		win_icon=$img_wine_desk_ui
		edit_win=$($yad_bin --width=420 --title "$w_title" --image=$win_icon --borders=15 \
			--window-icon=$img_desktop --center --separator=';' --form --item-separator="#" \
			--align=left --text "$w_text" --field="":LBL '' \
			--field="$vb Select a Wine bottle$end":CB "$bottle_list" \
			)
		fi	
	else
		win_icon=$img_wine_ui
		unset nv_field nv_list
		if [ $($lpci_bin| grep -c "NVIDIA") -gt 0 ]; then
			nv_field+=("--field=:LBL")
			nv_list+=('')
			nv_field+=("--field=$vb Select a Wine bottle$end:CB")
			nv_list+=("$bottle_list")
			nv_field+=("--field=$vb Select edit option$end:CB")
			nv_list+=('Edit the whole bottle#Edit config file directly#Edit Nvidia options only')
			w_text="$bf Wine bottle edition$end$vb\\n \
You can choose between edit a entire bottle or the Nvidia OpenGL environment options only$end"
		else
			w_text="$bf Wine bottle edition$end$vb\\n \
Select the Wne bottle to edit$end"
			nv_field+=("--field=:LBL")
			nv_list+=('')
			nv_field+=("--field=$vb Select a Wine bottle$end:CB")
			nv_list+=("$bottle_list")
			nv_field+=("--field=$vb Select edit option$end:CB")
			nv_list+=('Edit the whole bottle#Edit config file directly')
		fi
		edit_win=$($yad_bin --width=420 --title "$w_title" --image=$win_icon --borders=15 \
		--window-icon=$img_desktop --center --separator=';' --form --item-separator="#" \
		--align=left --text "$w_text" "${nv_field[@]}" "${nv_list[@]}")
	fi
	if [ $? = 1 ]; then exit 0; fi
	_edit_bottle=$(printf "${edit_win[@]}"| cut -d';' -f2)
	config_file=$HOME/.winestarter/configs/$_edit_bottle.conf
	if [ $desktop_file = 0 ]; then
		if [ $(printf "${edit_win[@]}"| grep -c "Nvidia") -gt 0 ];then
			code=1; else code=0
		fi
	fi
	if [ $rstart = 1 ]; then
		_winecfg=$(printf "${edit_win[@]}"| cut -d';' -f3)
		_winetrk=$(printf "${edit_win[@]}"| cut -d';' -f4)
		[[ $_winecfg == TRUE ]]&& perl -ni -pe "s|^(w_config)=([0-9])$|\1=1|i" $config_file
		[[ $_winetrk == TRUE ]]&& perl -ni -pe "s|^(w_install_tricks)=([0-9])$|\1=1|i" $config_file
		exit 0
	fi
	if [ -e $HOME/.winestarter/configs/$_edit_bottle.conf ]; then
		## if previous option is config file direct edit, launch zenity text edit and exit.
		if [ $(printf "${edit_win[@]}"| grep -c "directly") -gt 0 ];then
			e_text="$bf\\Fast Config Edit$end\n This editor is for quick config edits. All '##' comments are removable if you're confortable without them, but we don't recommand it."
			edit_config=$($yad_bin --width=800 --height=600 --title="$w_title" --borders=15 \
			--window-icon=$img_wine_desk_ui --text-info  --text="$vb$e_text$end" \
			--editable --filename=$config_file)
			if [ $? = 1 ]; then
				exit 0
			else
				echo "$edit_config" > $config_file
			fi
			exit 0
			
		fi
		from_config=1
		export from_config=$from_config config_file=$config_file
		## Cause of a too much long loading time, better to place winetricks basic_sets here
		## and then, export it as appropriate.
		fn_make_tricks_menu
		## check if selection is desktop file entry or not
		if [ $desktop_file = 1 ]; then
			bash $bash_opt "colors; icons_set; edit_desktop"
		else
			bash $bash_opt "colors; icons_set; b_set=0; code=$code; main_code"
		fi
	else
		exit 0
	fi
	exit 0
}
. $HOME/.config/user-dirs.dirs
## Script debug options
#bash_opt='-x -c'
bash_opt='-c'
## Main button commands
main_cmd_0="bash $bash_opt \"colors; icons_set; b_set=1; code=0; from_config=0; main_code\""
main_cmd_1="bash $bash_opt \"colors; icons_set; b_set=0; from_config=1; desktop_file=0; rstart=0; edit_bottle\""
main_cmd_2="bash $bash_opt \"colors; icons_set; from_config=1; desktop_file=1; rstart=0; edit_bottle\""
main_cmd_3="bash $bash_opt \"colors; icons_set; change_fonts_colors\""
main_cmd_4="bash $bash_opt \"colors; icons_set; from_config=1; desktop_file=1; rstart=1; edit_bottle\""

the_big_button="$HOME/.winestarter/png/defaults/winestarter_128.png"

main_text3="$vb\\Create$end"
main_text4="$vb\\Modify$end"

list_bottles
#messages; main_code
main_text0="$bf\\Stay simple with yours Wine bottles$end$vb\\n\
\"Don't be a clic machine !\"$end\\n\\n\
$vb\\What do you want to do?$end\\n$vn(Hover buttons show tooltips)$end"

export -f colors icons_set
export -f main_code edit_bottle edit_desktop list_bottles change_fonts_colors select_wine_bin select_wine_dis select_wine_binary download_list edit_reg_bin edit_regfile edit_wine_options
export w_title="winestarter configurator" base_script="$0" bash_opt="$bash_opt"
$yad_bin --width=520 --title "Winestarter configurator"  --window-icon=$img_wine_desk_ui --no-buttons \
--form --text="$main_text0" --image=$the_big_button  --borders=15 \
--field="":LBL '' \
--field="$main_text3":LBL '' \
--field="$vb New Wine prefix $end"!$img_wine_add!"Create and config a fresh new Wine prefix":FBTN "$main_cmd_0" \
--field="$main_text4":LBL '' \
--field="$vb Edit a Wine bottle$end"!$img_wine_mod!"Add or change features, options, etc in an existing Wine bottle":FBTN "$main_cmd_1" \
--field="$vb Edit or create a Desktop file$end"!$img_wine_desk_bt!"Create a new or modify an existing Wine bottle Desktop file":FBTN "$main_cmd_2" \
--field="$vb Change fonts colors$end"!$img_wine_colors!"If you occur issues with default fonts colors, you can change them here":FBTN "$main_cmd_3" \
--field="$vb Restart features$end"!$img_wine_restart!"You can restart here some functions at next launch, ex: winecfg":FBTN "$main_cmd_4"

exit 0

